FileName,Caller,Source,Sink,idx,CWE-ID,category,criterion,line,label,slices,tokenized,token_length,predict
manager.c,build_config,False,False,0,CWE-,CallExpression,strlen,98,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    fprintf(f, ""{\\n"");\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n', '    fprintf(f, ""\\n}\\n"");\n', '    fclose(f);\n', '    ss_free(path);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
Var2=FUNC2(Var3); 
snprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
FUNC3(Var2); 
fprintf(Var4,STRING); 
fprintf(Var4,STRING STRUCT3 STRING,FUNC4(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
fprintf(Var4,STRING); 
fclose(Var4); 
FUNC3(Var2); 
",375,0
manager.c,build_config,False,False,1,CWE-,CallExpression,strlen,98,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    fprintf(f, ""{\\n"");\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n', '    fprintf(f, ""\\n}\\n"");\n', '    fclose(f);\n', '    ss_free(path);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
Var2=FUNC2(Var3); 
snprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
FUNC3(Var2); 
fprintf(Var4,STRING); 
fprintf(Var4,STRING STRUCT3 STRING,FUNC4(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
fprintf(Var4,STRING); 
fclose(Var4); 
FUNC3(Var2); 
",375,0
manager.c,build_config,False,False,2,CWE-,CallExpression,snprintf,101,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n', '    ss_free(path);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
Var2=FUNC2(Var3); 
snprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
FUNC3(Var2); 
fprintf(Var4,STRING STRUCT3 STRING,FUNC4(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
FUNC3(Var2); 
",350,0
manager.c,build_config,False,False,3,CWE-,CallExpression,fopen,102,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    fprintf(f, ""{\\n"");\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n', '    fprintf(f, ""\\n}\\n"");\n', '    fclose(f);\n', '    ss_free(path);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
Var2=FUNC2(Var3); 
snprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
FUNC3(Var2); 
fprintf(Var4,STRING); 
fprintf(Var4,STRING STRUCT3 STRING,FUNC4(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
fprintf(Var4,STRING); 
fclose(Var4); 
FUNC3(Var2); 
",375,0
manager.c,build_config,False,False,4,CWE-,CallExpression,fprintf,110,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    path = ss_malloc(path_size);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '    fprintf(f, ""{\\n"");\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n', '    fprintf(f, ""\\n}\\n"");\n', '    fclose(f);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
Var2=FUNC2(Var3); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
fprintf(Var4,STRING); 
fprintf(Var4,STRING STRUCT3 STRING,FUNC3(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
fprintf(Var4,STRING); 
fclose(Var4); 
",338,0
manager.c,build_config,False,False,5,CWE-,CallExpression,fprintf,111,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '    fprintf(f, ""{\\n"");\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n', '    fprintf(f, ""\\n}\\n"");\n', '    fclose(f);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
Var2=FUNC2(Var3); 
snprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
fprintf(Var4,STRING); 
fprintf(Var4,STRING STRUCT3 STRING,FUNC3(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
fprintf(Var4,STRING); 
fclose(Var4); 
",359,0
manager.c,build_config,False,False,6,CWE-,CallExpression,atoi,111,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '    fprintf(f, ""{\\n"");\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n', '    fprintf(f, ""\\n}\\n"");\n', '    fclose(f);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
Var2=FUNC2(Var3); 
snprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
fprintf(Var4,STRING); 
fprintf(Var4,STRING STRUCT3 STRING,FUNC3(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
fprintf(Var4,STRING); 
fclose(Var4); 
",359,0
manager.c,build_config,False,False,7,CWE-,CallExpression,fprintf,112,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '    fprintf(f, ""{\\n"");\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n', '    fprintf(f, ""\\n}\\n"");\n', '    fclose(f);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
Var2=FUNC2(Var3); 
snprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
fprintf(Var4,STRING); 
fprintf(Var4,STRING STRUCT3 STRING,FUNC3(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
fprintf(Var4,STRING); 
fclose(Var4); 
",359,0
manager.c,build_config,False,False,8,CWE-,CallExpression,fprintf,113,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
snprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
fprintf(Var4,STRING STRUCT3 STRING,FUNC2(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
",323,0
manager.c,build_config,False,False,9,CWE-,CallExpression,fprintf,114,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
snprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
fprintf(Var4,STRING STRUCT3 STRING,FUNC2(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
",323,0
manager.c,build_config,False,False,10,CWE-,CallExpression,fprintf,115,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
snprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
fprintf(Var4,STRING STRUCT3 STRING,FUNC2(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
",323,0
manager.c,build_config,False,False,11,CWE-,CallExpression,fprintf,116,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
snprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
fprintf(Var4,STRING STRUCT3 STRING,FUNC2(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
",323,0
manager.c,build_config,False,False,12,CWE-,CallExpression,fprintf,117,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
snprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
fprintf(Var4,STRING STRUCT3 STRING,FUNC2(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
",323,0
manager.c,build_config,False,False,13,CWE-,CallExpression,fprintf,118,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    path = ss_malloc(path_size);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '    fprintf(f, ""{\\n"");\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n', '    fprintf(f, ""\\n}\\n"");\n', '    fclose(f);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
Var2=FUNC2(Var3); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
fprintf(Var4,STRING); 
fprintf(Var4,STRING STRUCT3 STRING,FUNC3(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
fprintf(Var4,STRING); 
fclose(Var4); 
",338,0
manager.c,build_config,False,False,14,CWE-,CallExpression,fclose,119,-3,"['build_config(char *prefix, struct server *server)\n', '    char *path    = NULL;\n', '    int path_size = strlen(prefix) + strlen(server->port) + 20;\n', '    path = ss_malloc(path_size);\n', '    FILE *f = fopen(path, ""w+"");\n', '    if (f == NULL) {\n', '    fprintf(f, ""{\\n"");\n', '    fprintf(f, ""\\""server_port\\"":%d,\\n"", atoi(server->port));\n', '    fprintf(f, ""\\""password\\"":\\""%s\\"""", server->password);\n', '    if (server->fast_open[0]) fprintf(f, "",\\n\\""fast_open\\"": %s"", server->fast_open);\n', '    if (server->mode)   fprintf(f, "",\\n\\""mode\\"":\\""%s\\"""", server->mode);\n', '    if (server->method) fprintf(f, "",\\n\\""method\\"":\\""%s\\"""", server->method);\n', '    if (server->plugin) fprintf(f, "",\\n\\""plugin\\"":\\""%s\\"""", server->plugin);\n', '    if (server->plugin_opts) fprintf(f, "",\\n\\""plugin_opts\\"":\\""%s\\"""", server->plugin_opts);\n', '    fprintf(f, ""\\n}\\n"");\n', '    fclose(f);\n']","FUNC1(char *Var1,struct STRUCT1 *STRUCT1)
char *Var2=NULL ; 
int  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; 
Var2=FUNC2(Var3); 
STRUCT2 *Var4=fopen(Var2,STRING); 
if (Var4 == NULL ){
fprintf(Var4,STRING); 
fprintf(Var4,STRING STRUCT3 STRING,FUNC3(STRUCT1->memberVar1)); 
fprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); 
if (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); 
if (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); 
if (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); 
if (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); 
if (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); 
fprintf(Var4,STRING); 
fclose(Var4); 
",338,0
manager.c,construct_command_line,False,False,15,CWE-,CallExpression,memset,133,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,16,CWE-,CallExpression,snprintf,134,-3,"['construct_command_line(struct manager_ctx *manager, struct server *server)\n', '    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    build_config(working_dir, server);\n', '    if (server->method) method = server->method;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
static char  Var2[Var3]; 
char *Var4=Var1->memberVar1; 
int  Var5; 
FUNC2(Var6,STRUCT2); 
if (STRUCT2->memberVar1) memberVar1=STRUCT2->memberVar1; 
memset(Var2,0,Var3); 
snprintf(Var2,Var3,
STRING,
Var7,memberVar1,Var1->memberVar2,
Var6,STRUCT2->memberVar2,Var6,STRUCT2->memberVar2); 
if (Var1->memberVar3 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); 
if (Var1->memberVar4 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); 
if (Var1->memberVar5){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); 
if (Var1->memberVar6 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); 
if (Var1->memberVar7){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar3 == NULL &&Var1->memberVar8 ==  Var9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar3 == NULL &&Var1->memberVar8 ==  Var10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar4[0]== 0&&Var1->memberVar9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); 
if (STRUCT2->memberVar5 == NULL &&Var1->memberVar12){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); 
if (STRUCT2->memberVar6 == NULL &&Var1->memberVar13){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); 
for (Var5=0; Var5<Var1->memberVar14; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); 
for (Var5=0; Var5<Var1->memberVar16; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); 
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (memberVar7){
FUNC3(STRING,Var2); 
return  Var2; 
",957,0
manager.c,construct_command_line,False,False,17,CWE-,CallExpression,strlen,140,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,18,CWE-,CallExpression,snprintf,141,-3,"['construct_command_line(struct manager_ctx *manager, struct server *server)\n', '    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
static char  Var2[Var3]; 
char *Var4=Var1->memberVar1; 
int  Var5; 
memset(Var2,0,Var3); 
snprintf(Var2,Var3,
STRING,
Var6,memberVar1,Var1->memberVar2,
Var7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); 
if (Var1->memberVar3 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); 
if (Var1->memberVar4 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); 
if (Var1->memberVar5){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); 
if (Var1->memberVar6 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); 
if (Var1->memberVar7){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); 
if (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); 
if (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); 
for (Var5=0; Var5<Var1->memberVar14; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); 
for (Var5=0; Var5<Var1->memberVar16; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); 
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (memberVar7){
FUNC2(STRING,Var2); 
return  Var2; 
",926,0
manager.c,construct_command_line,False,False,19,CWE-,CallExpression,strlen,144,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,20,CWE-,CallExpression,snprintf,145,-3,"['construct_command_line(struct manager_ctx *manager, struct server *server)\n', '    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
static char  Var2[Var3]; 
char *Var4=Var1->memberVar1; 
int  Var5; 
memset(Var2,0,Var3); 
snprintf(Var2,Var3,
STRING,
Var6,memberVar1,Var1->memberVar2,
Var7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); 
if (Var1->memberVar3 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); 
if (Var1->memberVar4 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); 
if (Var1->memberVar5){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); 
if (Var1->memberVar6 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); 
if (Var1->memberVar7){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); 
if (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); 
if (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); 
for (Var5=0; Var5<Var1->memberVar14; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); 
for (Var5=0; Var5<Var1->memberVar16; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); 
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (memberVar7){
FUNC2(STRING,Var2); 
return  Var2; 
",926,0
manager.c,construct_command_line,False,False,21,CWE-,CallExpression,strlen,149,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,22,CWE-,CallExpression,snprintf,150,-3,"['construct_command_line(struct manager_ctx *manager, struct server *server)\n', '    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
static char  Var2[Var3]; 
char *Var4=Var1->memberVar1; 
int  Var5; 
memset(Var2,0,Var3); 
snprintf(Var2,Var3,
STRING,
Var6,memberVar1,Var1->memberVar2,
Var7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); 
if (Var1->memberVar3 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); 
if (Var1->memberVar4 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); 
if (Var1->memberVar5){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); 
if (Var1->memberVar6 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); 
if (Var1->memberVar7){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); 
if (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); 
if (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); 
for (Var5=0; Var5<Var1->memberVar14; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); 
for (Var5=0; Var5<Var1->memberVar16; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); 
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (memberVar7){
FUNC2(STRING,Var2); 
return  Var2; 
",926,0
manager.c,construct_command_line,False,False,23,CWE-,CallExpression,strlen,154,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,24,CWE-,CallExpression,snprintf,155,-3,"['construct_command_line(struct manager_ctx *manager, struct server *server)\n', '    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
static char  Var2[Var3]; 
char *Var4=Var1->memberVar1; 
int  Var5; 
memset(Var2,0,Var3); 
snprintf(Var2,Var3,
STRING,
Var6,memberVar1,Var1->memberVar2,
Var7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); 
if (Var1->memberVar3 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); 
if (Var1->memberVar4 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); 
if (Var1->memberVar5){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); 
if (Var1->memberVar6 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); 
if (Var1->memberVar7){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); 
if (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); 
if (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); 
for (Var5=0; Var5<Var1->memberVar14; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); 
for (Var5=0; Var5<Var1->memberVar16; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); 
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (memberVar7){
FUNC2(STRING,Var2); 
return  Var2; 
",926,0
manager.c,construct_command_line,False,False,25,CWE-,CallExpression,strlen,158,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,26,CWE-,CallExpression,snprintf,159,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,27,CWE-,CallExpression,strlen,162,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,28,CWE-,CallExpression,snprintf,163,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,29,CWE-,CallExpression,strlen,166,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,30,CWE-,CallExpression,snprintf,167,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,31,CWE-,CallExpression,strlen,170,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,32,CWE-,CallExpression,snprintf,171,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,33,CWE-,CallExpression,strlen,174,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,34,CWE-,CallExpression,snprintf,175,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,35,CWE-,CallExpression,strlen,178,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,36,CWE-,CallExpression,snprintf,179,-3,"['construct_command_line(struct manager_ctx *manager, struct server *server)\n', '    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
static char  Var2[Var3]; 
char *Var4=Var1->memberVar1; 
int  Var5; 
memset(Var2,0,Var3); 
snprintf(Var2,Var3,
STRING,
Var6,memberVar1,Var1->memberVar2,
Var7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); 
if (Var1->memberVar3 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); 
if (Var1->memberVar4 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); 
if (Var1->memberVar5){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); 
if (Var1->memberVar6 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); 
if (Var1->memberVar7){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); 
if (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); 
if (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); 
for (Var5=0; Var5<Var1->memberVar14; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); 
for (Var5=0; Var5<Var1->memberVar16; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); 
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (memberVar7){
FUNC2(STRING,Var2); 
return  Var2; 
",926,0
manager.c,construct_command_line,False,False,37,CWE-,CallExpression,strlen,182,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,38,CWE-,CallExpression,snprintf,183,-3,"['construct_command_line(struct manager_ctx *manager, struct server *server)\n', '    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
static char  Var2[Var3]; 
char *Var4=Var1->memberVar1; 
int  Var5; 
memset(Var2,0,Var3); 
snprintf(Var2,Var3,
STRING,
Var6,memberVar1,Var1->memberVar2,
Var7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); 
if (Var1->memberVar3 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); 
if (Var1->memberVar4 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); 
if (Var1->memberVar5){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); 
if (Var1->memberVar6 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); 
if (Var1->memberVar7){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); 
if (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); 
if (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); 
for (Var5=0; Var5<Var1->memberVar14; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); 
for (Var5=0; Var5<Var1->memberVar16; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); 
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (memberVar7){
FUNC2(STRING,Var2); 
return  Var2; 
",926,0
manager.c,construct_command_line,False,False,39,CWE-,CallExpression,strlen,186,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,40,CWE-,CallExpression,snprintf,187,-3,"['construct_command_line(struct manager_ctx *manager, struct server *server)\n', '    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
static char  Var2[Var3]; 
char *Var4=Var1->memberVar1; 
int  Var5; 
memset(Var2,0,Var3); 
snprintf(Var2,Var3,
STRING,
Var6,memberVar1,Var1->memberVar2,
Var7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); 
if (Var1->memberVar3 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); 
if (Var1->memberVar4 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); 
if (Var1->memberVar5){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); 
if (Var1->memberVar6 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); 
if (Var1->memberVar7){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); 
if (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); 
if (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); 
for (Var5=0; Var5<Var1->memberVar14; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); 
for (Var5=0; Var5<Var1->memberVar16; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); 
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (memberVar7){
FUNC2(STRING,Var2); 
return  Var2; 
",926,0
manager.c,construct_command_line,False,False,41,CWE-,CallExpression,strlen,190,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,42,CWE-,CallExpression,snprintf,191,-3,"['construct_command_line(struct manager_ctx *manager, struct server *server)\n', '    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
static char  Var2[Var3]; 
char *Var4=Var1->memberVar1; 
int  Var5; 
memset(Var2,0,Var3); 
snprintf(Var2,Var3,
STRING,
Var6,memberVar1,Var1->memberVar2,
Var7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); 
if (Var1->memberVar3 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); 
if (Var1->memberVar4 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); 
if (Var1->memberVar5){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); 
if (Var1->memberVar6 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); 
if (Var1->memberVar7){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); 
if (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); 
if (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); 
for (Var5=0; Var5<Var1->memberVar14; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); 
for (Var5=0; Var5<Var1->memberVar16; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); 
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (memberVar7){
FUNC2(STRING,Var2); 
return  Var2; 
",926,0
manager.c,construct_command_line,False,False,43,CWE-,CallExpression,strlen,194,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,44,CWE-,CallExpression,snprintf,195,-3,"['construct_command_line(struct manager_ctx *manager, struct server *server)\n', '    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
static char  Var2[Var3]; 
char *Var4=Var1->memberVar1; 
int  Var5; 
memset(Var2,0,Var3); 
snprintf(Var2,Var3,
STRING,
Var6,memberVar1,Var1->memberVar2,
Var7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); 
if (Var1->memberVar3 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); 
if (Var1->memberVar4 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); 
if (Var1->memberVar5){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); 
if (Var1->memberVar6 != NULL ){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); 
if (Var1->memberVar7){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar10){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (Var1->memberVar11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); 
if (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); 
if (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); 
for (Var5=0; Var5<Var1->memberVar14; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); 
for (Var5=0; Var5<Var1->memberVar16; Var5  Var11){
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); 
int  Var8=strlen(Var2); 
snprintf(Var2+Var8,Var3-Var8,STRING); 
if (memberVar7){
FUNC2(STRING,Var2); 
return  Var2; 
",926,0
manager.c,construct_command_line,False,False,45,CWE-,CallExpression,strlen,199,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,construct_command_line,False,False,46,CWE-,CallExpression,snprintf,200,-3,"['    static char cmd[BUF_SIZE];\n', '    char *method = manager->method;\n', '    int i;\n', '    memset(cmd, 0, BUF_SIZE);\n', '    snprintf(cmd, BUF_SIZE,\n             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n', '    if (manager->acl != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);\n', '    if (manager->timeout != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);\n', '    if (manager->nofile) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);\n', '    if (manager->user != NULL) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);\n', '    if (manager->verbose) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -v"");\n', '    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -U"");\n', '    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -u"");\n', '    if (server->fast_open[0] == 0 && manager->fast_open) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");\n', '    if (manager->ipv6first) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -6"");\n', '    if (manager->mtu) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);\n', '    if (server->plugin == NULL && manager->plugin) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \\""%s\\"""", manager->plugin);\n', '    if (server->plugin_opts == NULL && manager->plugin_opts) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \\""%s\\"""", manager->plugin_opts);\n', '    for (i = 0; i < manager->nameserver_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);\n', '    for (i = 0; i < manager->host_num; i++) {\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);\n', '        int len = strlen(cmd);\n', '        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");\n', '    if (verbose) {\n', '        LOGI(""cmd: %s"", cmd);\n', '    return cmd;\n']","static char  Var1[Var2]; 
char *Var3=Var4->memberVar1; 
int  Var5; 
memset(Var1,0,Var2); 
snprintf(Var1,Var2,
STRING,
Var6,memberVar1,Var4->memberVar2,
Var7,Var8->memberVar1,Var7,Var8->memberVar1); 
if (Var4->memberVar3 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); 
if (Var4->memberVar4 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); 
if (Var4->memberVar5){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); 
if (Var4->memberVar6 != NULL ){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); 
if (Var4->memberVar7){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var8->memberVar3[0]== 0&&Var4->memberVar9){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar10){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (Var4->memberVar11){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); 
if (Var8->memberVar4 == NULL &&Var4->memberVar12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); 
if (Var8->memberVar5 == NULL &&Var4->memberVar13){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); 
for (Var5=0; Var5<Var4->memberVar14; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); 
for (Var5=0; Var5<Var4->memberVar16; Var5  Var12){
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); 
int  Var9=strlen(Var1); 
snprintf(Var1+Var9,Var2-Var9,STRING); 
if (memberVar7){
FUNC1(STRING,Var1); 
return  Var1; 
",904,0
manager.c,get_server,False,False,47,CWE-,CallExpression,strlen,258,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '        LOGE(""%s"", error_buf);\n', '    struct server *server = ss_malloc(sizeof(struct server));\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', '                if (value->type == json_string) {\n', 'else\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', '                if (value->type == json_string) {\n', '                    strncpy(server->password, value->u.string.ptr, 128);\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->method = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', '                if (value->type == json_boolean) {\n', '                    strncpy(server->fast_open, (value->u.boolean ? ""true"" : ""false""), 8);\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin_opts = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->mode = strdup(value->u.string.ptr);\n', 'else\n', '                LOGE(""invalid data: %s"", data);\n', '    json_value_free(obj);\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
FUNC4(STRING,Var4); 
struct STRUCT2 *STRUCT2=FUNC5(sizeof (struct  STRUCT2)); 
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
else 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
strncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var13){
strncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
FUNC4(STRING,Var3); 
FUNC6(Var5); 
",651,0
manager.c,get_server,False,False,48,CWE-,CallExpression,memset,266,-3,"['    char *data = get_data(buf, len);\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    struct server *server = ss_malloc(sizeof(struct server));\n', '    memset(server, 0, sizeof(struct server));\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', '                if (value->type == json_string) {\n', 'else\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', '                if (value->type == json_string) {\n', '                    strncpy(server->password, value->u.string.ptr, 128);\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->method = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', '                if (value->type == json_boolean) {\n', '                    strncpy(server->fast_open, (value->u.boolean ? ""true"" : ""false""), 8);\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin_opts = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->mode = strdup(value->u.string.ptr);\n', '    return server;\n']","char *Var1=FUNC1(Var2,Var3); 
if (Var1 == NULL ){
STRUCT1 *Var4=FUNC2(&Var5,Var1,strlen(Var1),Var6); 
if (Var4 == NULL ){
struct STRUCT2 *STRUCT2=FUNC3(sizeof (struct  STRUCT2)); 
memset(STRUCT2,0,sizeof (struct  STRUCT2)); 
if (Var4->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var4->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var4->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var4->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
else 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
strncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var13){
strncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
return  STRUCT2; 
",621,0
manager.c,get_server,False,False,49,CWE-,CallExpression,strcmp,272,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
",346,0
manager.c,get_server,False,False,50,CWE-,CallExpression,strncpy,274,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    struct server *server = ss_malloc(sizeof(struct server));\n', '    memset(server, 0, sizeof(struct server));\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', '                if (value->type == json_string) {\n', 'else\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', '                if (value->type == json_string) {\n', '                    strncpy(server->password, value->u.string.ptr, 128);\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->method = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', '                if (value->type == json_boolean) {\n', '                    strncpy(server->fast_open, (value->u.boolean ? ""true"" : ""false""), 8);\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin_opts = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->mode = strdup(value->u.string.ptr);\n', '    return server;\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
struct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); 
memset(STRUCT2,0,sizeof (struct  STRUCT2)); 
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
else 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
strncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var13){
strncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
return  STRUCT2; 
",645,0
manager.c,get_server,False,False,51,CWE-,CallExpression,strcmp,278,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
",346,0
manager.c,get_server,False,False,52,CWE-,CallExpression,strncpy,280,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    struct server *server = ss_malloc(sizeof(struct server));\n', '    memset(server, 0, sizeof(struct server));\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', '                if (value->type == json_string) {\n', 'else\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', '                if (value->type == json_string) {\n', '                    strncpy(server->password, value->u.string.ptr, 128);\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->method = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', '                if (value->type == json_boolean) {\n', '                    strncpy(server->fast_open, (value->u.boolean ? ""true"" : ""false""), 8);\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin_opts = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->mode = strdup(value->u.string.ptr);\n', '    return server;\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
struct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); 
memset(STRUCT2,0,sizeof (struct  STRUCT2)); 
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
else 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
strncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var13){
strncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
return  STRUCT2; 
",645,0
manager.c,get_server,False,False,53,CWE-,CallExpression,strcmp,282,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
",346,0
manager.c,get_server,False,False,54,CWE-,CallExpression,strdup,284,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    struct server *server = ss_malloc(sizeof(struct server));\n', '    memset(server, 0, sizeof(struct server));\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', '                if (value->type == json_string) {\n', 'else\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', '                if (value->type == json_string) {\n', '                    strncpy(server->password, value->u.string.ptr, 128);\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->method = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', '                if (value->type == json_boolean) {\n', '                    strncpy(server->fast_open, (value->u.boolean ? ""true"" : ""false""), 8);\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin_opts = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->mode = strdup(value->u.string.ptr);\n', '    return server;\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
struct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); 
memset(STRUCT2,0,sizeof (struct  STRUCT2)); 
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
else 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
strncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var13){
strncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
return  STRUCT2; 
",645,0
manager.c,get_server,False,False,55,CWE-,CallExpression,strcmp,286,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
",346,0
manager.c,get_server,False,False,56,CWE-,CallExpression,strncpy,288,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    struct server *server = ss_malloc(sizeof(struct server));\n', '    memset(server, 0, sizeof(struct server));\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', '                if (value->type == json_string) {\n', 'else\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', '                if (value->type == json_string) {\n', '                    strncpy(server->password, value->u.string.ptr, 128);\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->method = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', '                if (value->type == json_boolean) {\n', '                    strncpy(server->fast_open, (value->u.boolean ? ""true"" : ""false""), 8);\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin_opts = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->mode = strdup(value->u.string.ptr);\n', '    return server;\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
struct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); 
memset(STRUCT2,0,sizeof (struct  STRUCT2)); 
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
else 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
strncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var13){
strncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
return  STRUCT2; 
",645,0
manager.c,get_server,False,False,57,CWE-,CallExpression,strcmp,290,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
",346,0
manager.c,get_server,False,False,58,CWE-,CallExpression,strdup,292,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    struct server *server = ss_malloc(sizeof(struct server));\n', '    memset(server, 0, sizeof(struct server));\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', '                if (value->type == json_string) {\n', 'else\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', '                if (value->type == json_string) {\n', '                    strncpy(server->password, value->u.string.ptr, 128);\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->method = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', '                if (value->type == json_boolean) {\n', '                    strncpy(server->fast_open, (value->u.boolean ? ""true"" : ""false""), 8);\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin_opts = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->mode = strdup(value->u.string.ptr);\n', '    return server;\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
struct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); 
memset(STRUCT2,0,sizeof (struct  STRUCT2)); 
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
else 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
strncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var13){
strncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
return  STRUCT2; 
",645,0
manager.c,get_server,False,False,59,CWE-,CallExpression,strcmp,294,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
",346,0
manager.c,get_server,False,False,60,CWE-,CallExpression,strdup,296,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    struct server *server = ss_malloc(sizeof(struct server));\n', '    memset(server, 0, sizeof(struct server));\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', '                if (value->type == json_string) {\n', 'else\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', '                if (value->type == json_string) {\n', '                    strncpy(server->password, value->u.string.ptr, 128);\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->method = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', '                if (value->type == json_boolean) {\n', '                    strncpy(server->fast_open, (value->u.boolean ? ""true"" : ""false""), 8);\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin_opts = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->mode = strdup(value->u.string.ptr);\n', '    return server;\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
struct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); 
memset(STRUCT2,0,sizeof (struct  STRUCT2)); 
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
else 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
strncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var13){
strncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
return  STRUCT2; 
",645,0
manager.c,get_server,False,False,61,CWE-,CallExpression,strcmp,298,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
else 
}else if (strcmp(memberVar1,STRING) == 0){
",346,0
manager.c,get_server,False,False,62,CWE-,CallExpression,strdup,300,-3,"['get_server(char *buf, int len)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    struct server *server = ss_malloc(sizeof(struct server));\n', '    memset(server, 0, sizeof(struct server));\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (strcmp(name, ""server_port"") == 0) {\n', '                if (value->type == json_string) {\n', 'else\n', 'else\n', '            } else if (strcmp(name, ""password"") == 0) {\n', '                if (value->type == json_string) {\n', '                    strncpy(server->password, value->u.string.ptr, 128);\n', 'else\n', '            } else if (strcmp(name, ""method"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->method = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""fast_open"") == 0) {\n', '                if (value->type == json_boolean) {\n', '                    strncpy(server->fast_open, (value->u.boolean ? ""true"" : ""false""), 8);\n', 'else\n', '            } else if (strcmp(name, ""plugin"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""plugin_opts"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->plugin_opts = strdup(value->u.string.ptr);\n', 'else\n', '            } else if (strcmp(name, ""mode"") == 0) {\n', '                if (value->type == json_string) {\n', '                    server->mode = strdup(value->u.string.ptr);\n', '    return server;\n']","FUNC1(char *Var1,int  Var2)
char *Var3=FUNC2(Var1,Var2); 
char  Var4[512]; 
if (Var3 == NULL ){
STRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); 
if (Var5 == NULL ){
struct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); 
memset(STRUCT2,0,sizeof (struct  STRUCT2)); 
if (Var5->memberVar1 ==  Var7){
int  Var8=0; 
for (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){
char *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; 
STRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; 
if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
else 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
strncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var13){
strncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
else 
}else if (strcmp(memberVar1,STRING) == 0){
if (memberVar2->memberVar1 ==  Var12){
STRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); 
return  STRUCT2; 
",645,0
manager.c,parse_traffic,False,False,63,CWE-,CallExpression,strlen,325,-3,"['parse_traffic(char *buf, int len, char *port, uint64_t *traffic)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '        LOGE(""%s"", error_buf);\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (value->type == json_integer) {\n', '                strncpy(port, name, 8);\n', '                *traffic = value->u.integer;\n', '    json_value_free(obj);\n']","FUNC1(char *Var1,int  Var2,char *Var3,uint64_t *Var4)
char *Var5=FUNC2(Var1,Var2); 
char  Var6[512]; 
if (Var5 == NULL ){
STRUCT1 *Var7=FUNC3(&Var8,Var5,strlen(Var5),Var6); 
if (Var7 == NULL ){
FUNC4(STRING,Var6); 
if (Var7->memberVar1 ==  Var9){
int  Var10=0; 
for (Var10=0; Var10<Var7->memberVar2.memberVar1.memberVar1; Var10  Var11){
char *Var12=Var7->memberVar2.memberVar1.memberVar2[Var10].memberVar1; 
STRUCT1 *Var13=Var7->memberVar2.memberVar1.memberVar2[Var10].memberVar2; 
if (memberVar2->memberVar1 ==  Var14){
strncpy(Var3,memberVar1,8); 
*Var4=memberVar2->memberVar2.memberVar2; 
FUNC5(Var7); 
",276,0
manager.c,parse_traffic,False,False,64,CWE-,CallExpression,strncpy,337,-3,"['parse_traffic(char *buf, int len, char *port, uint64_t *traffic)\n', '    char *data = get_data(buf, len);\n', '    char error_buf[512];\n', '    if (data == NULL) {\n', '    json_value *obj = json_parse_ex(&settings, data, strlen(data), error_buf);\n', '    if (obj == NULL) {\n', '    if (obj->type == json_object) {\n', '        int i = 0;\n', '        for (i = 0; i < obj->u.object.length; i++) {\n', '            char *name        = obj->u.object.values[i].name;\n', '            json_value *value = obj->u.object.values[i].value;\n', '            if (value->type == json_integer) {\n', '                strncpy(port, name, 8);\n']","FUNC1(char *Var1,int  Var2,char *Var3,uint64_t *Var4)
char *Var5=FUNC2(Var1,Var2); 
char  Var6[512]; 
if (Var5 == NULL ){
STRUCT1 *Var7=FUNC3(&Var8,Var5,strlen(Var5),Var6); 
if (Var7 == NULL ){
if (Var7->memberVar1 ==  Var9){
int  Var10=0; 
for (Var10=0; Var10<Var7->memberVar2.memberVar1.memberVar1; Var10  Var11){
char *Var12=Var7->memberVar2.memberVar1.memberVar2[Var10].memberVar1; 
STRUCT1 *Var13=Var7->memberVar2.memberVar1.memberVar2[Var10].memberVar2; 
if (memberVar2->memberVar1 ==  Var14){
strncpy(Var3,memberVar1,8); 
",244,0
manager.c,create_and_bind,False,False,65,CWE-,CallExpression,memset,354,-3,"['    memset(&hints, 0, sizeof(struct addrinfo));\n']","memset(&Var1,0,sizeof (struct  Var2)); 
",18,0
manager.c,create_and_bind,False,False,66,CWE-,CallExpression,getaddrinfo,361,-3,"['create_and_bind(const char *host, const char *port, int protocol)\n', '    struct addrinfo *result, *rp, *ipv4v6bindall;\n', '    int s, listen_sock = -1;\n', '    s = getaddrinfo(host, port, &hints, &result);\n', '    if (s != 0) {\n', '        LOGE(""getaddrinfo: %s"", gai_strerror(s));\n', '    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n', '        if (listen_sock == -1) {\n', '        if (rp->ai_family == AF_INET6) {\n', '            int ipv6only = host ? 1 : 0;\n', '        if (s == 0) {\n']","FUNC1(const char *Var1,const char *Var2,int  Var3)
struct STRUCT1 *Var4,*Var5,*Var6; 
int  Var7,Var8=-1; 
Var7=getaddrinfo(Var1,Var2,&Var9,&Var4); 
if (Var7 != 0){
FUNC2(STRING,FUNC3(Var7)); 
for (/*Var5=Var4 */; Var5 != NULL ; Var5=Var5->memberVar1){
if (Var8 == -1){
if (Var5->memberVar2 ==  Var10){
int  Var11=Var1 10; 
if (Var7 == 0){
",185,0
manager.c,create_and_bind,False,False,67,CWE-,CallExpression,socket,390,-3,"['    struct addrinfo *result, *rp, *ipv4v6bindall;\n', '    int s, listen_sock = -1;\n', '    if (s != 0) {\n', '    rp = result;\n', '    if (!host) {\n', '        ipv4v6bindall = result;\n', '        while (ipv4v6bindall) {\n', '            if (ipv4v6bindall->ai_family == AF_INET6) {\n', '                rp = ipv4v6bindall; /* Take first IPV6 address available */\n', '            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n', '    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n', '        listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n', '        if (listen_sock == -1) {\n', '        if (rp->ai_family == AF_INET6) {\n', '            int ipv6only = host ? 1 : 0;\n', '            setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n', '        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n', '        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));\n', '        s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);\n', '        if (s == 0) {\n', '            close(listen_sock);\n', '    if (rp == NULL) {\n', '    return listen_sock;\n']","struct STRUCT1 *Var1,*Var2,*Var3; 
int  Var4,Var5=-1; 
if (Var4 != 0){
Var2=Var1; 
if (!Var6){
Var3=Var1; 
while (Var3){
if (Var3->memberVar1 ==  Var7){
Var2=Var3; /*Var8  Var9  Var10  STRUCT2 STRUCT3 */
Var3=Var3->memberVar2; /*Var11  Var12  STRUCT2  Var13,if STRUCT4 */
for (/*Var2=Var1 */; Var2 != NULL ; Var2=Var2->memberVar1){
Var5=socket(Var2->memberVar2,Var2->memberVar3,Var2->memberVar4); 
if (Var5 == -1){
if (Var2->memberVar2 ==  Var7){
int  Var14=Var6 10; 
FUNC1(Var5,Var15,Var16,&Var14,sizeof (Var14)); 
FUNC1(Var5,Var17,Var18,&Var19,sizeof (Var19)); 
FUNC1(Var5,Var17,Var20,&Var19,sizeof (Var19)); 
Var4=FUNC2(Var5,Var2->memberVar5,Var2->memberVar6); 
if (Var4 == 0){
close(Var5); 
if (Var2 == NULL ){
return  Var5; 
",380,0
manager.c,create_and_bind,False,False,68,CWE-,CallExpression,close,410,-3,"['    struct addrinfo *result, *rp, *ipv4v6bindall;\n', '    int s, listen_sock = -1;\n', '    if (s != 0) {\n', '    rp = result;\n', '    if (!host) {\n', '        ipv4v6bindall = result;\n', '        while (ipv4v6bindall) {\n', '            if (ipv4v6bindall->ai_family == AF_INET6) {\n', '                rp = ipv4v6bindall; /* Take first IPV6 address available */\n', '            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n', '    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n', '        listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n', '        if (listen_sock == -1) {\n', '        if (rp->ai_family == AF_INET6) {\n', '            int ipv6only = host ? 1 : 0;\n', '            setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n', '        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n', '        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));\n', '        s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);\n', '        if (s == 0) {\n', '            close(listen_sock);\n', '    if (rp == NULL) {\n', '    return listen_sock;\n']","struct STRUCT1 *Var1,*Var2,*Var3; 
int  Var4,Var5=-1; 
if (Var4 != 0){
Var2=Var1; 
if (!Var6){
Var3=Var1; 
while (Var3){
if (Var3->memberVar1 ==  Var7){
Var2=Var3; /*Var8  Var9  Var10  STRUCT2 STRUCT3 */
Var3=Var3->memberVar2; /*Var11  Var12  STRUCT2  Var13,if STRUCT4 */
for (/*Var2=Var1 */; Var2 != NULL ; Var2=Var2->memberVar1){
Var5=socket(Var2->memberVar2,Var2->memberVar3,Var2->memberVar4); 
if (Var5 == -1){
if (Var2->memberVar2 ==  Var7){
int  Var14=Var6 10; 
FUNC1(Var5,Var15,Var16,&Var14,sizeof (Var14)); 
FUNC1(Var5,Var17,Var18,&Var19,sizeof (Var19)); 
FUNC1(Var5,Var17,Var20,&Var19,sizeof (Var19)); 
Var4=FUNC2(Var5,Var2->memberVar5,Var2->memberVar6); 
if (Var4 == 0){
close(Var5); 
if (Var2 == NULL ){
return  Var5; 
",380,0
manager.c,check_port,False,False,69,CWE-,CallExpression,memset,438,-3,"['check_port(struct manager_ctx *manager, struct server *server)\n', '    bool both_tcp_udp = manager->mode == TCP_AND_UDP;\n', '    int fd_count      = manager->host_num * (both_tcp_udp ? 2 : 1);\n', '    int *sock_fds = (int *)ss_malloc(fd_count * sizeof(int));\n', '    memset(sock_fds, 0, fd_count * sizeof(int));\n', '    for (int i = 0; i < manager->host_num; i++) {\n', '        if (manager->mode == UDP_ONLY) {\n', '            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n', 'else\n', '            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_TCP);\n', '        if (both_tcp_udp) {\n', '            sock_fds[i + manager->host_num] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n', '        if (sock_fds[i] == -1 || (both_tcp_udp && sock_fds[i + manager->host_num] == -1)) {\n', '    for (int i = 0; i < fd_count; i++) {\n', '        if (sock_fds[i] > 0) {\n', '            close(sock_fds[i]);\n', '    ss_free(sock_fds);\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
bool  Var2=Var1->memberVar1 ==  Var3; 
int  Var4=Var1->STRUCT3 *(Var2 21); 
int *Var5=(int *) FUNC2(Var4 *sizeof (int )); 
memset(Var5,0,Var4 *sizeof (int )); 
for (int  Var6=0; Var6<Var1->memberVar2; Var6  Var7){
if (Var1->memberVar1 ==  Var8){
Var5[Var6]=FUNC3(Var1->memberVar3[Var6],STRUCT2->memberVar1,Var9); 
else 
Var5[Var6]=FUNC3(Var1->memberVar3[Var6],STRUCT2->memberVar1,Var10); 
if (Var2){
Var5[Var6+Var1->memberVar2]=FUNC3(Var1->memberVar3[Var6],STRUCT2->memberVar1,Var9); 
if (Var5[Var6]== -1||(Var2&&Var5[Var6+Var1->memberVar2]== -1)){
for (int  Var6=0; Var6<Var4; Var6  Var7){
if (Var5[Var6]>0){
close(Var5[Var6]); 
FUNC4(Var5); 
",358,0
manager.c,check_port,False,False,70,CWE-,CallExpression,close,463,-3,"['check_port(struct manager_ctx *manager, struct server *server)\n', '    bool both_tcp_udp = manager->mode == TCP_AND_UDP;\n', '    int fd_count      = manager->host_num * (both_tcp_udp ? 2 : 1);\n', '    int *sock_fds = (int *)ss_malloc(fd_count * sizeof(int));\n', '    memset(sock_fds, 0, fd_count * sizeof(int));\n', '    for (int i = 0; i < manager->host_num; i++) {\n', '        LOGI(""try to bind interface: %s, port: %s"", manager->hosts[i], server->port);\n', '        if (manager->mode == UDP_ONLY) {\n', '            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n', 'else\n', '            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_TCP);\n', '        if (both_tcp_udp) {\n', '            sock_fds[i + manager->host_num] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n', '        if (sock_fds[i] == -1 || (both_tcp_udp && sock_fds[i + manager->host_num] == -1)) {\n', '    for (int i = 0; i < fd_count; i++) {\n', '        if (sock_fds[i] > 0) {\n', '            close(sock_fds[i]);\n', '    ss_free(sock_fds);\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
bool  Var2=Var1->memberVar1 ==  Var3; 
int  Var4=Var1->STRUCT3 *(Var2 21); 
int *Var5=(int *) FUNC2(Var4 *sizeof (int )); 
memset(Var5,0,Var4 *sizeof (int )); 
for (int  Var6=0; Var6<Var1->memberVar2; Var6  Var7){
FUNC3(STRING,Var1->memberVar3[Var6],STRUCT2->memberVar1); 
if (Var1->memberVar1 ==  Var8){
Var5[Var6]=FUNC4(Var1->memberVar3[Var6],STRUCT2->memberVar1,Var9); 
else 
Var5[Var6]=FUNC4(Var1->memberVar3[Var6],STRUCT2->memberVar1,Var10); 
if (Var2){
Var5[Var6+Var1->memberVar2]=FUNC4(Var1->memberVar3[Var6],STRUCT2->memberVar1,Var9); 
if (Var5[Var6]== -1||(Var2&&Var5[Var6+Var1->memberVar2]== -1)){
for (int  Var6=0; Var6<Var4; Var6  Var7){
if (Var5[Var6]>0){
close(Var5[Var6]); 
FUNC5(Var5); 
",381,0
manager.c,add_server,False,False,71,CWE-,CallExpression,system,486,-3,"['add_server(struct manager_ctx *manager, struct server *server)\n', '    int ret = check_port(manager, server);\n', '    if (ret == -1) {\n', '    char *cmd = construct_command_line(manager, server);\n']","FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)
int  Var2=FUNC2(Var1,STRUCT2); 
if (Var2 == -1){
char *Var3=FUNC3(Var1,STRUCT2); 
",67,0
manager.c,kill_server,False,False,72,CWE-,CallExpression,strlen,498,-3,"['kill_server(char *prefix, char *pid_file)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/%s"", prefix, pid_file);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    if (fscanf(f, ""%d"", &pid) != EOF) {\n', '        kill(pid, SIGTERM);\n', '    fclose(f);\n', '    remove(path);\n', '    ss_free(path);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+2; 
Var3=FUNC2(Var5); 
snprintf(Var3,Var5,STRING,Var1,Var2); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
FUNC3(Var3); 
if (fscanf(Var6,STRING,&Var4) !=  Var7){
FUNC4(Var4,Var8); 
fclose(Var6); 
remove(Var3); 
FUNC3(Var3); 
",169,0
manager.c,kill_server,False,False,73,CWE-,CallExpression,strlen,498,-3,"['kill_server(char *prefix, char *pid_file)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/%s"", prefix, pid_file);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    if (fscanf(f, ""%d"", &pid) != EOF) {\n', '        kill(pid, SIGTERM);\n', '    fclose(f);\n', '    remove(path);\n', '    ss_free(path);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+2; 
Var3=FUNC2(Var5); 
snprintf(Var3,Var5,STRING,Var1,Var2); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
FUNC3(Var3); 
if (fscanf(Var6,STRING,&Var4) !=  Var7){
FUNC4(Var4,Var8); 
fclose(Var6); 
remove(Var3); 
FUNC3(Var3); 
",169,0
manager.c,kill_server,False,False,74,CWE-,CallExpression,snprintf,500,-3,"['kill_server(char *prefix, char *pid_file)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/%s"", prefix, pid_file);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    remove(path);\n', '    ss_free(path);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+2; 
Var3=FUNC2(Var5); 
snprintf(Var3,Var5,STRING,Var1,Var2); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
FUNC3(Var3); 
remove(Var3); 
FUNC3(Var3); 
",129,0
manager.c,kill_server,False,False,75,CWE-,CallExpression,fopen,501,-3,"['kill_server(char *prefix, char *pid_file)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/%s"", prefix, pid_file);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    fclose(f);\n', '    remove(path);\n', '    ss_free(path);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+2; 
Var3=FUNC2(Var5); 
snprintf(Var3,Var5,STRING,Var1,Var2); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
FUNC3(Var3); 
fclose(Var6); 
remove(Var3); 
FUNC3(Var3); 
",136,0
manager.c,kill_server,False,False,76,CWE-,CallExpression,fscanf,509,-3,"['kill_server(char *prefix, char *pid_file)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n', '    path = ss_malloc(path_size);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '    fclose(f);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+2; 
Var3=FUNC2(Var5); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
fclose(Var6); 
",95,0
manager.c,kill_server,False,False,77,CWE-,CallExpression,fclose,512,-3,"['kill_server(char *prefix, char *pid_file)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n', '    path = ss_malloc(path_size);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '    fclose(f);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+2; 
Var3=FUNC2(Var5); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
fclose(Var6); 
",95,0
manager.c,kill_server,False,False,78,CWE-,CallExpression,remove,513,-3,"['kill_server(char *prefix, char *pid_file)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/%s"", prefix, pid_file);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    remove(path);\n', '    ss_free(path);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+2; 
Var3=FUNC2(Var5); 
snprintf(Var3,Var5,STRING,Var1,Var2); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
FUNC3(Var3); 
remove(Var3); 
FUNC3(Var3); 
",129,0
manager.c,stop_server,False,False,79,CWE-,CallExpression,strlen,521,-3,"['stop_server(char *prefix, char *port)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.pid"", prefix, port);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    if (fscanf(f, ""%d"", &pid) != EOF) {\n', '        kill(pid, SIGTERM);\n', '    fclose(f);\n', '    ss_free(path);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+20; 
Var3=FUNC2(Var5); 
snprintf(Var3,Var5,STRING,Var1,Var2); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
FUNC3(Var3); 
if (fscanf(Var6,STRING,&Var4) !=  Var7){
FUNC4(Var4,Var8); 
fclose(Var6); 
FUNC3(Var3); 
",162,0
manager.c,stop_server,False,False,80,CWE-,CallExpression,strlen,521,-3,"['stop_server(char *prefix, char *port)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.pid"", prefix, port);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    if (fscanf(f, ""%d"", &pid) != EOF) {\n', '        kill(pid, SIGTERM);\n', '    fclose(f);\n', '    ss_free(path);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+20; 
Var3=FUNC2(Var5); 
snprintf(Var3,Var5,STRING,Var1,Var2); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
FUNC3(Var3); 
if (fscanf(Var6,STRING,&Var4) !=  Var7){
FUNC4(Var4,Var8); 
fclose(Var6); 
FUNC3(Var3); 
",162,0
manager.c,stop_server,False,False,81,CWE-,CallExpression,snprintf,523,-3,"['stop_server(char *prefix, char *port)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.pid"", prefix, port);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    ss_free(path);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+20; 
Var3=FUNC2(Var5); 
snprintf(Var3,Var5,STRING,Var1,Var2); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
FUNC3(Var3); 
FUNC3(Var3); 
",122,0
manager.c,stop_server,False,False,82,CWE-,CallExpression,fopen,524,-3,"['stop_server(char *prefix, char *port)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n', '    path = ss_malloc(path_size);\n', '    snprintf(path, path_size, ""%s/.shadowsocks_%s.pid"", prefix, port);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '        ss_free(path);\n', '    fclose(f);\n', '    ss_free(path);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+20; 
Var3=FUNC2(Var5); 
snprintf(Var3,Var5,STRING,Var1,Var2); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
FUNC3(Var3); 
fclose(Var6); 
FUNC3(Var3); 
",129,0
manager.c,stop_server,False,False,83,CWE-,CallExpression,fscanf,532,-3,"['stop_server(char *prefix, char *port)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n', '    path = ss_malloc(path_size);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '    fclose(f);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+20; 
Var3=FUNC2(Var5); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
fclose(Var6); 
",95,0
manager.c,stop_server,False,False,84,CWE-,CallExpression,fclose,535,-3,"['stop_server(char *prefix, char *port)\n', '    char *path = NULL;\n', '    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n', '    path = ss_malloc(path_size);\n', '    FILE *f = fopen(path, ""r"");\n', '    if (f == NULL) {\n', '    fclose(f);\n']","FUNC1(char *Var1,char *Var2)
char *Var3=NULL ; 
int  Var4,Var5=strlen(Var1)+strlen(Var2)+20; 
Var3=FUNC2(Var5); 
STRUCT1 *Var6=fopen(Var3,STRING); 
if (Var6 == NULL ){
fclose(Var6); 
",95,0
manager.c,manager_recv_cb,False,False,85,CWE-,CallExpression,memset,577,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    memset(buf, 0, BUF_SIZE);\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n', '            LOGE(""invalid command: %s:%s"", buf, get_data(buf, r));\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0) {\n', '            LOGE(""invalid command: %s:%s"", buf, get_data(buf, r));\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', '        char port[8];\n', '        if (parse_traffic(buf, r, port, &traffic) == -1) {\n', '            LOGE(""invalid command: %s:%s"", buf, get_data(buf, r));\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n', '    strcpy(buf, ""err"");\n']","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
Var4=recvfrom(Var1->memberVar1,Var5,Var6,0,(struct STRUCT4 *)&Var7,&Var3); 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var8=FUNC1(Var5,Var4); 
if (Var8 == NULL ){
if (strcmp(Var8,STRING) == 0){
struct STRUCT5 *STRUCT5=FUNC2(Var5,Var4); 
if (STRUCT5 == NULL ||STRUCT5->memberVar1[0]== 0||STRUCT5->memberVar2[0]== 0){
FUNC3(STRING,Var5,FUNC4(Var5,Var4)); 
int  Var9=FUNC5(Var1,STRUCT5); 
else 
}else if (strcmp(Var8,STRING) == 0){
char  Var5[Var6]; 
struct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var10->memberVar1; 
char *Var11=STRUCT5->Var11  STRUCT5->Var11  Var1->memberVar2; 
size_t  Var12=strlen(Var5); 
size_t  Var13=strlen(STRUCT5->memberVar1)+strlen(STRUCT5->memberVar2)+strlen(memberVar2); 
size_t  Var12=strlen(Var5); 
else 
}else if (strcmp(Var8,STRING) == 0){
struct STRUCT5 *STRUCT5=FUNC2(Var5,Var4); 
if (STRUCT5 == NULL ||STRUCT5->memberVar1[0]== 0){
FUNC3(STRING,Var5,FUNC4(Var5,Var4)); 
else 
}else if (strcmp(Var8,STRING) == 0){
char  memberVar1[8]; 
if (FUNC6(Var5,Var4,memberVar1,&Var14) == -1){
FUNC3(STRING,Var5,FUNC4(Var5,Var4)); 
char  Var5[Var6]; 
struct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var10->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
strcpy(Var5,STRING); 
",625,0
manager.c,manager_recv_cb,False,False,86,CWE-,CallExpression,recvfrom,580,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    memset(buf, 0, BUF_SIZE);\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '        LOGE(""too large request: %d"", (int)r);\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n', '            LOGE(""invalid command: %s:%s"", buf, get_data(buf, r));\n', '            if (server != NULL) {\n', '                destroy_server(server);\n', '                ss_free(server);\n', '        remove_server(working_dir, server->port);\n', '        int ret = add_server(manager, server);\n', '        char *msg;\n', '        int msg_len;\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0) {\n', '            LOGE(""invalid command: %s:%s"", buf, get_data(buf, r));\n', '            if (server != NULL) {\n', '                destroy_server(server);\n', '                ss_free(server);\n', '        remove_server(working_dir, server->port);\n', '        destroy_server(server);\n', '        ss_free(server);\n', '        char msg[3] = ""ok"";\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', '        char port[8];\n', '        if (parse_traffic(buf, r, port, &traffic) == -1) {\n', '            LOGE(""invalid command: %s:%s"", buf, get_data(buf, r));\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', '        size_t pos = strlen(buf);\n', '    strcpy(buf, ""err"");\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
STRUCT5  Var5; 
char  Var6[Var7]; 
memset(Var6,0,Var7); 
Var5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var8,&Var4); 
if (Var5 == -1){
if (Var5>Var7/2){
FUNC2(STRING,(int ) Var5); 
char *Var9=FUNC3(Var6,Var5); 
if (Var9 == NULL ){
if (strcmp(Var9,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC4(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){
FUNC2(STRING,Var6,FUNC5(Var6,Var5)); 
if (STRUCT7 != NULL ){
FUNC6(STRUCT7); 
FUNC7(STRUCT7); 
FUNC8(Var10,STRUCT7->memberVar1); 
int  Var11=FUNC9(Var3,STRUCT7); 
char *Var12; 
int  Var13; 
else 
}else if (strcmp(Var9,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
while ((Var14=FUNC10(&Var15)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
char *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; 
size_t  Var17=strlen(Var6); 
size_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); 
if (Var17>Var7-Var18-50){
size_t  Var17=strlen(Var6); 
else 
}else if (strcmp(Var9,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC4(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){
FUNC2(STRING,Var6,FUNC5(Var6,Var5)); 
if (STRUCT7 != NULL ){
FUNC6(STRUCT7); 
FUNC7(STRUCT7); 
FUNC8(Var10,STRUCT7->memberVar1); 
FUNC6(STRUCT7); 
FUNC7(STRUCT7); 
char  Var12[3]=STRING; 
else 
}else if (strcmp(Var9,STRING) == 0){
char  memberVar1[8]; 
if (FUNC11(Var6,Var5,memberVar1,&Var19) == -1){
FUNC2(STRING,Var6,FUNC5(Var6,Var5)); 
else 
}else if (strcmp(Var9,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
while ((Var14=FUNC10(&Var20)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
size_t  Var17=strlen(Var6); 
if (Var17>Var7/2){
size_t  Var17=strlen(Var6); 
strcpy(Var6,STRING); 
",901,0
manager.c,manager_recv_cb,False,False,87,CWE-,CallExpression,strcmp,596,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        char buf[BUF_SIZE];\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        char buf[BUF_SIZE];\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
char  Var5[Var6]; 
Var4=recvfrom(Var3->memberVar1,Var5,Var6,0,(struct STRUCT5 *)&Var7,&Var8); 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var9=FUNC2(Var5,Var4); 
if (Var9 == NULL ){
if (strcmp(Var9,STRING) == 0){
struct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); 
int  Var10=FUNC4(Var3,STRUCT6); 
else 
}else if (strcmp(Var9,STRING) == 0){
char  Var5[Var6]; 
char *Var11=STRUCT6->Var11  STRUCT6->Var11  Var3->memberVar2; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
else 
}else if (strcmp(Var9,STRING) == 0){
struct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); 
else 
}else if (strcmp(Var9,STRING) == 0){
else 
}else if (strcmp(Var9,STRING) == 0){
char  Var5[Var6]; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",399,0
manager.c,manager_recv_cb,False,False,88,CWE-,CallExpression,sendto,622,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    len = sizeof(struct sockaddr_un);\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n', '        int ret = add_server(manager, server);\n', '        char *msg;\n', '        int msg_len;\n', '        if (ret == -1) {\n', '            msg     = ""port is not available"";\n', '            msg_len = 21;\n', 'else\n', '            msg     = ""ok"";\n', '            msg_len = 2;\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0) {\n', '        char msg[3] = ""ok"";\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
STRUCT5  Var5; 
char  Var6[Var7]; 
Var4=sizeof (struct  Var8); 
Var5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); 
if (Var5 == -1){
if (Var5>Var7/2){
char *Var10=FUNC2(Var6,Var5); 
if (Var10 == NULL ){
if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){
int  Var11=FUNC4(Var3,STRUCT7); 
char *Var12; 
int  Var13; 
if (Var11 == -1){
Var12=STRING; 
Var13=21; 
else 
Var12=STRING; 
Var13=2; 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
while ((Var14=FUNC5(&Var15)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
char *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; 
size_t  Var17=strlen(Var6); 
size_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); 
if (Var17>Var7-Var18-50){
size_t  Var17=strlen(Var6); 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){
char  Var12[3]=STRING; 
else 
}else if (strcmp(Var10,STRING) == 0){
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
while ((Var14=FUNC5(&Var19)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
size_t  Var17=strlen(Var6); 
if (Var17>Var7/2){
size_t  Var17=strlen(Var6); 
",719,0
manager.c,manager_recv_cb,False,False,89,CWE-,CallExpression,strcmp,625,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        char buf[BUF_SIZE];\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        char buf[BUF_SIZE];\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
char  Var5[Var6]; 
Var4=recvfrom(Var3->memberVar1,Var5,Var6,0,(struct STRUCT5 *)&Var7,&Var8); 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var9=FUNC2(Var5,Var4); 
if (Var9 == NULL ){
if (strcmp(Var9,STRING) == 0){
struct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); 
int  Var10=FUNC4(Var3,STRUCT6); 
else 
}else if (strcmp(Var9,STRING) == 0){
char  Var5[Var6]; 
char *Var11=STRUCT6->Var11  STRUCT6->Var11  Var3->memberVar2; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
else 
}else if (strcmp(Var9,STRING) == 0){
struct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); 
else 
}else if (strcmp(Var9,STRING) == 0){
else 
}else if (strcmp(Var9,STRING) == 0){
char  Var5[Var6]; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",399,0
manager.c,manager_recv_cb,False,False,90,CWE-,CallExpression,memset,629,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""["");\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '                memset(buf, 0, BUF_SIZE);\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        strcpy(buf + pos - 1, ""\\n]""); //Remove trailing "",""\n', '        pos = strlen(buf);\n', '        struct server *server = get_server(buf, r);\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC1(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
int  Var8=FUNC3(Var1,STRUCT4); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
sprintf(Var5,STRING); 
while ((Var9=FUNC4(&Var10)) != NULL ){
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
char *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); 
if (Var12>Var6-Var13-50){
memset(Var5,0,Var6); 
sprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,
STRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); 
size_t  Var12=strlen(Var5); 
strcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING
Var12=strlen(Var5); 
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",551,0
manager.c,manager_recv_cb,False,False,91,CWE-,CallExpression,sprintf,630,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""["");\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '                memset(buf, 0, BUF_SIZE);\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        strcpy(buf + pos - 1, ""\\n]""); //Remove trailing "",""\n', '        pos = strlen(buf);\n', '        struct server *server = get_server(buf, r);\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC1(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
int  Var8=FUNC3(Var1,STRUCT4); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
sprintf(Var5,STRING); 
while ((Var9=FUNC4(&Var10)) != NULL ){
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
char *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); 
if (Var12>Var6-Var13-50){
memset(Var5,0,Var6); 
sprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,
STRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); 
size_t  Var12=strlen(Var5); 
strcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING
Var12=strlen(Var5); 
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",551,0
manager.c,manager_recv_cb,False,False,92,CWE-,CallExpression,strlen,636,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""["");\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '                memset(buf, 0, BUF_SIZE);\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        strcpy(buf + pos - 1, ""\\n]""); //Remove trailing "",""\n', '        pos = strlen(buf);\n', '        struct server *server = get_server(buf, r);\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC1(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
int  Var8=FUNC3(Var1,STRUCT4); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
sprintf(Var5,STRING); 
while ((Var9=FUNC4(&Var10)) != NULL ){
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
char *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); 
if (Var12>Var6-Var13-50){
memset(Var5,0,Var6); 
sprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,
STRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); 
size_t  Var12=strlen(Var5); 
strcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING
Var12=strlen(Var5); 
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",551,0
manager.c,manager_recv_cb,False,False,93,CWE-,CallExpression,strlen,637,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        struct server *server = get_server(buf, r);\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC2(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *STRUCT5=FUNC3(Var5,Var4); 
int  Var8=FUNC4(Var3,STRUCT5); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT6 *Var9; 
char  Var5[Var6]; 
while ((Var9=FUNC5(&Var10)) != NULL ){
struct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var9->memberVar1; 
char *Var11=STRUCT5->Var11  STRUCT5->Var11  Var3->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var13=strlen(STRUCT5->memberVar1)+strlen(STRUCT5->memberVar2)+strlen(memberVar1); 
sprintf(Var5+Var12,STRING STRUCT7 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,
STRUCT5->memberVar1,STRUCT5->memberVar2,memberVar1); 
size_t  Var12=strlen(Var5); 
struct STRUCT5 *STRUCT5=FUNC3(Var5,Var4); 
struct STRUCT6 *Var9; 
char  Var5[Var6]; 
struct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var9->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",480,0
manager.c,manager_recv_cb,False,False,94,CWE-,CallExpression,strlen,637,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        struct server *server = get_server(buf, r);\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC2(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *STRUCT5=FUNC3(Var5,Var4); 
int  Var8=FUNC4(Var3,STRUCT5); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT6 *Var9; 
char  Var5[Var6]; 
while ((Var9=FUNC5(&Var10)) != NULL ){
struct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var9->memberVar1; 
char *Var11=STRUCT5->Var11  STRUCT5->Var11  Var3->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var13=strlen(STRUCT5->memberVar1)+strlen(STRUCT5->memberVar2)+strlen(memberVar1); 
sprintf(Var5+Var12,STRING STRUCT7 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,
STRUCT5->memberVar1,STRUCT5->memberVar2,memberVar1); 
size_t  Var12=strlen(Var5); 
struct STRUCT5 *STRUCT5=FUNC3(Var5,Var4); 
struct STRUCT6 *Var9; 
char  Var5[Var6]; 
struct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var9->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",480,0
manager.c,manager_recv_cb,False,False,95,CWE-,CallExpression,strlen,637,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        struct server *server = get_server(buf, r);\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC2(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *STRUCT5=FUNC3(Var5,Var4); 
int  Var8=FUNC4(Var3,STRUCT5); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT6 *Var9; 
char  Var5[Var6]; 
while ((Var9=FUNC5(&Var10)) != NULL ){
struct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var9->memberVar1; 
char *Var11=STRUCT5->Var11  STRUCT5->Var11  Var3->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var13=strlen(STRUCT5->memberVar1)+strlen(STRUCT5->memberVar2)+strlen(memberVar1); 
sprintf(Var5+Var12,STRING STRUCT7 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,
STRUCT5->memberVar1,STRUCT5->memberVar2,memberVar1); 
size_t  Var12=strlen(Var5); 
struct STRUCT5 *STRUCT5=FUNC3(Var5,Var4); 
struct STRUCT6 *Var9; 
char  Var5[Var6]; 
struct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var9->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",480,0
manager.c,manager_recv_cb,False,False,96,CWE-,CallExpression,sendto,639,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    len = sizeof(struct sockaddr_un);\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n', '        int ret = add_server(manager, server);\n', '        char *msg;\n', '        int msg_len;\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""["");\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '                memset(buf, 0, BUF_SIZE);\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        strcpy(buf + pos - 1, ""\\n]""); //Remove trailing "",""\n', '        pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0) {\n', '        char msg[3] = ""ok"";\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
STRUCT5  Var5; 
char  Var6[Var7]; 
Var4=sizeof (struct  Var8); 
Var5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); 
if (Var5 == -1){
if (Var5>Var7/2){
char *Var10=FUNC2(Var6,Var5); 
if (Var10 == NULL ){
if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){
int  Var11=FUNC4(Var3,STRUCT7); 
char *Var12; 
int  Var13; 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
memset(Var6,0,Var7); 
sprintf(Var6,STRING); 
while ((Var14=FUNC5(&Var15)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
char *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; 
size_t  Var17=strlen(Var6); 
size_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); 
if (Var17>Var7-Var18-50){
memset(Var6,0,Var7); 
sprintf(Var6+Var17,STRING STRUCT9 STRING%Var19 STRING memberVar2 STRING%Var19 STRING memberVar2 STRING%Var19 STRING,
STRUCT7->memberVar1,STRUCT7->memberVar2,memberVar2); 
size_t  Var17=strlen(Var6); 
strcpy(Var6+Var17-1,STRING); //Var20  STRUCT10 STRING
Var17=strlen(Var6); 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){
char  Var12[3]=STRING; 
else 
}else if (strcmp(Var10,STRING) == 0){
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
while ((Var14=FUNC5(&Var21)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
size_t  Var17=strlen(Var6); 
if (Var17>Var7/2){
size_t  Var17=strlen(Var6); 
",805,0
manager.c,manager_recv_cb,False,False,97,CWE-,CallExpression,memset,643,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""["");\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '                memset(buf, 0, BUF_SIZE);\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        strcpy(buf + pos - 1, ""\\n]""); //Remove trailing "",""\n', '        pos = strlen(buf);\n', '        struct server *server = get_server(buf, r);\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC1(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
int  Var8=FUNC3(Var1,STRUCT4); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
sprintf(Var5,STRING); 
while ((Var9=FUNC4(&Var10)) != NULL ){
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
char *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); 
if (Var12>Var6-Var13-50){
memset(Var5,0,Var6); 
sprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,
STRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); 
size_t  Var12=strlen(Var5); 
strcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING
Var12=strlen(Var5); 
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",551,0
manager.c,manager_recv_cb,False,False,98,CWE-,CallExpression,sprintf,646,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""["");\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '                memset(buf, 0, BUF_SIZE);\n', '                pos = 0;\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        strcpy(buf + pos - 1, ""\\n]""); //Remove trailing "",""\n', '        pos = strlen(buf);\n', '        struct server *server = get_server(buf, r);\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
STRUCT5  Var5; 
char  Var6[Var7]; 
if (Var5 == -1){
if (Var5>Var7/2){
char *Var8=FUNC2(Var6,Var5); 
if (Var8 == NULL ){
if (strcmp(Var8,STRING) == 0){
struct STRUCT6 *STRUCT6=FUNC3(Var6,Var5); 
int  Var9=FUNC4(Var3,STRUCT6); 
else 
}else if (strcmp(Var8,STRING) == 0){
struct STRUCT7 *Var10; 
char  Var6[Var7]; 
memset(Var6,0,Var7); 
sprintf(Var6,STRING); 
while ((Var10=FUNC5(&Var11)) != NULL ){
struct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var10->memberVar1; 
char *Var12=STRUCT6->Var12  STRUCT6->Var12  Var3->memberVar1; 
size_t  Var13=strlen(Var6); 
size_t  Var14=strlen(STRUCT6->memberVar1)+strlen(STRUCT6->memberVar2)+strlen(memberVar1); 
if (Var13>Var7-Var14-50){
memset(Var6,0,Var7); 
Var13=0; 
sprintf(Var6+Var13,STRING STRUCT8 STRING%Var15 STRING memberVar2 STRING%Var15 STRING memberVar1 STRING%Var15 STRING,
STRUCT6->memberVar1,STRUCT6->memberVar2,memberVar1); 
size_t  Var13=strlen(Var6); 
strcpy(Var6+Var13-1,STRING); //Var16  STRUCT9 STRING
Var13=strlen(Var6); 
struct STRUCT6 *STRUCT6=FUNC3(Var6,Var5); 
struct STRUCT7 *Var10; 
char  Var6[Var7]; 
struct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var10->memberVar1; 
size_t  Var13=strlen(Var6); 
size_t  Var13=strlen(Var6); 
",576,0
manager.c,manager_recv_cb,False,False,99,CWE-,CallExpression,strlen,651,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""["");\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '                memset(buf, 0, BUF_SIZE);\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        strcpy(buf + pos - 1, ""\\n]""); //Remove trailing "",""\n', '        pos = strlen(buf);\n', '        struct server *server = get_server(buf, r);\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC1(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
int  Var8=FUNC3(Var1,STRUCT4); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
sprintf(Var5,STRING); 
while ((Var9=FUNC4(&Var10)) != NULL ){
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
char *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); 
if (Var12>Var6-Var13-50){
memset(Var5,0,Var6); 
sprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,
STRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); 
size_t  Var12=strlen(Var5); 
strcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING
Var12=strlen(Var5); 
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",551,0
manager.c,manager_recv_cb,False,False,100,CWE-,CallExpression,strcpy,652,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""["");\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '                memset(buf, 0, BUF_SIZE);\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        strcpy(buf + pos - 1, ""\\n]""); //Remove trailing "",""\n', '        pos = strlen(buf);\n', '        struct server *server = get_server(buf, r);\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC1(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
int  Var8=FUNC3(Var1,STRUCT4); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
sprintf(Var5,STRING); 
while ((Var9=FUNC4(&Var10)) != NULL ){
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
char *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); 
if (Var12>Var6-Var13-50){
memset(Var5,0,Var6); 
sprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,
STRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); 
size_t  Var12=strlen(Var5); 
strcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING
Var12=strlen(Var5); 
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",551,0
manager.c,manager_recv_cb,False,False,101,CWE-,CallExpression,strlen,653,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""["");\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '                memset(buf, 0, BUF_SIZE);\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        strcpy(buf + pos - 1, ""\\n]""); //Remove trailing "",""\n', '        pos = strlen(buf);\n', '        struct server *server = get_server(buf, r);\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC1(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
int  Var8=FUNC3(Var1,STRUCT4); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
sprintf(Var5,STRING); 
while ((Var9=FUNC4(&Var10)) != NULL ){
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
char *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); 
if (Var12>Var6-Var13-50){
memset(Var5,0,Var6); 
sprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,
STRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); 
size_t  Var12=strlen(Var5); 
strcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING
Var12=strlen(Var5); 
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",551,0
manager.c,manager_recv_cb,False,False,102,CWE-,CallExpression,sendto,654,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    len = sizeof(struct sockaddr_un);\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n', '        int ret = add_server(manager, server);\n', '        char *msg;\n', '        int msg_len;\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""["");\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '                memset(buf, 0, BUF_SIZE);\n', '            sprintf(buf + pos, ""\\n\\t{\\""server_port\\"":\\""%s\\"",\\""password\\"":\\""%s\\"",\\""method\\"":\\""%s\\""},"", \n                    server->port,server->password,method);\n', '        size_t pos = strlen(buf);\n', '        strcpy(buf + pos - 1, ""\\n]""); //Remove trailing "",""\n', '        pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0) {\n', '        char msg[3] = ""ok"";\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
STRUCT5  Var5; 
char  Var6[Var7]; 
Var4=sizeof (struct  Var8); 
Var5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); 
if (Var5 == -1){
if (Var5>Var7/2){
char *Var10=FUNC2(Var6,Var5); 
if (Var10 == NULL ){
if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){
int  Var11=FUNC4(Var3,STRUCT7); 
char *Var12; 
int  Var13; 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
memset(Var6,0,Var7); 
sprintf(Var6,STRING); 
while ((Var14=FUNC5(&Var15)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
char *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; 
size_t  Var17=strlen(Var6); 
size_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); 
if (Var17>Var7-Var18-50){
memset(Var6,0,Var7); 
sprintf(Var6+Var17,STRING STRUCT9 STRING%Var19 STRING memberVar2 STRING%Var19 STRING memberVar2 STRING%Var19 STRING,
STRUCT7->memberVar1,STRUCT7->memberVar2,memberVar2); 
size_t  Var17=strlen(Var6); 
strcpy(Var6+Var17-1,STRING); //Var20  STRUCT10 STRING
Var17=strlen(Var6); 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){
char  Var12[3]=STRING; 
else 
}else if (strcmp(Var10,STRING) == 0){
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
while ((Var14=FUNC5(&Var21)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
size_t  Var17=strlen(Var6); 
if (Var17>Var7/2){
size_t  Var17=strlen(Var6); 
",805,0
manager.c,manager_recv_cb,False,False,103,CWE-,CallExpression,strcmp,658,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        char buf[BUF_SIZE];\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        char buf[BUF_SIZE];\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
char  Var5[Var6]; 
Var4=recvfrom(Var3->memberVar1,Var5,Var6,0,(struct STRUCT5 *)&Var7,&Var8); 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var9=FUNC2(Var5,Var4); 
if (Var9 == NULL ){
if (strcmp(Var9,STRING) == 0){
struct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); 
int  Var10=FUNC4(Var3,STRUCT6); 
else 
}else if (strcmp(Var9,STRING) == 0){
char  Var5[Var6]; 
char *Var11=STRUCT6->Var11  STRUCT6->Var11  Var3->memberVar2; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
else 
}else if (strcmp(Var9,STRING) == 0){
struct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); 
else 
}else if (strcmp(Var9,STRING) == 0){
else 
}else if (strcmp(Var9,STRING) == 0){
char  Var5[Var6]; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",399,0
manager.c,manager_recv_cb,False,False,104,CWE-,CallExpression,sendto,675,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    len = sizeof(struct sockaddr_un);\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n', '        int ret = add_server(manager, server);\n', '        char *msg;\n', '        int msg_len;\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0) {\n', '        char msg[3] = ""ok"";\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
STRUCT5  Var5; 
char  Var6[Var7]; 
Var4=sizeof (struct  Var8); 
Var5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); 
if (Var5 == -1){
if (Var5>Var7/2){
char *Var10=FUNC2(Var6,Var5); 
if (Var10 == NULL ){
if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){
int  Var11=FUNC4(Var3,STRUCT7); 
char *Var12; 
int  Var13; 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
while ((Var14=FUNC5(&Var15)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
char *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; 
size_t  Var17=strlen(Var6); 
size_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); 
if (Var17>Var7-Var18-50){
size_t  Var17=strlen(Var6); 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){
char  Var12[3]=STRING; 
else 
}else if (strcmp(Var10,STRING) == 0){
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
while ((Var14=FUNC5(&Var19)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
size_t  Var17=strlen(Var6); 
if (Var17>Var7/2){
size_t  Var17=strlen(Var6); 
",680,0
manager.c,manager_recv_cb,False,False,105,CWE-,CallExpression,strcmp,678,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        char buf[BUF_SIZE];\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        char buf[BUF_SIZE];\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
char  Var5[Var6]; 
Var4=recvfrom(Var3->memberVar1,Var5,Var6,0,(struct STRUCT5 *)&Var7,&Var8); 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var9=FUNC2(Var5,Var4); 
if (Var9 == NULL ){
if (strcmp(Var9,STRING) == 0){
struct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); 
int  Var10=FUNC4(Var3,STRUCT6); 
else 
}else if (strcmp(Var9,STRING) == 0){
char  Var5[Var6]; 
char *Var11=STRUCT6->Var11  STRUCT6->Var11  Var3->memberVar2; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
else 
}else if (strcmp(Var9,STRING) == 0){
struct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); 
else 
}else if (strcmp(Var9,STRING) == 0){
else 
}else if (strcmp(Var9,STRING) == 0){
char  Var5[Var6]; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",399,0
manager.c,manager_recv_cb,False,False,106,CWE-,CallExpression,strcmp,688,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        char buf[BUF_SIZE];\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        char buf[BUF_SIZE];\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
char  Var5[Var6]; 
Var4=recvfrom(Var3->memberVar1,Var5,Var6,0,(struct STRUCT5 *)&Var7,&Var8); 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var9=FUNC2(Var5,Var4); 
if (Var9 == NULL ){
if (strcmp(Var9,STRING) == 0){
struct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); 
int  Var10=FUNC4(Var3,STRUCT6); 
else 
}else if (strcmp(Var9,STRING) == 0){
char  Var5[Var6]; 
char *Var11=STRUCT6->Var11  STRUCT6->Var11  Var3->memberVar2; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
else 
}else if (strcmp(Var9,STRING) == 0){
struct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); 
else 
}else if (strcmp(Var9,STRING) == 0){
else 
}else if (strcmp(Var9,STRING) == 0){
char  Var5[Var6]; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
",399,0
manager.c,manager_recv_cb,False,False,107,CWE-,CallExpression,memset,694,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""stat: {"");\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', ""                buf[pos - 1] = '}';\n"", '                memset(buf, 0, BUF_SIZE);\n', '        size_t pos = strlen(buf);\n', '        if (pos > 7) {\n', ""            buf[pos - 1] = '}';\n"", 'else\n', ""            buf[pos] = '}';\n""]","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC1(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
int  Var8=FUNC3(Var1,STRUCT4); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
char *Var10=STRUCT4->Var10  STRUCT4->Var10  Var1->memberVar1; 
size_t  Var11=strlen(Var5); 
size_t  Var12=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); 
size_t  Var11=strlen(Var5); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
else 
}else if (strcmp(Var7,STRING) == 0){
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
sprintf(Var5,STRING); 
while ((Var9=FUNC4(&Var13)) != NULL ){
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
size_t  Var11=strlen(Var5); 
if (Var11>Var6/2){
Var5[Var11-1]=}; 
memset(Var5,0,Var6); 
size_t  Var11=strlen(Var5); 
if (Var11>7){
Var5[Var11-1]=}; 
else 
Var5[Var11]=}; 
",565,0
manager.c,manager_recv_cb,False,False,108,CWE-,CallExpression,sprintf,695,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""stat: {"");\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', ""                buf[pos - 1] = '}';\n"", '                memset(buf, 0, BUF_SIZE);\n', '        size_t pos = strlen(buf);\n', '        if (pos > 7) {\n', ""            buf[pos - 1] = '}';\n"", 'else\n', ""            buf[pos] = '}';\n""]","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC1(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
int  Var8=FUNC3(Var1,STRUCT4); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
char *Var10=STRUCT4->Var10  STRUCT4->Var10  Var1->memberVar1; 
size_t  Var11=strlen(Var5); 
size_t  Var12=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); 
size_t  Var11=strlen(Var5); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
else 
}else if (strcmp(Var7,STRING) == 0){
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
sprintf(Var5,STRING); 
while ((Var9=FUNC4(&Var13)) != NULL ){
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
size_t  Var11=strlen(Var5); 
if (Var11>Var6/2){
Var5[Var11-1]=}; 
memset(Var5,0,Var6); 
size_t  Var11=strlen(Var5); 
if (Var11>7){
Var5[Var11-1]=}; 
else 
Var5[Var11]=}; 
",565,0
manager.c,manager_recv_cb,False,False,109,CWE-,CallExpression,strlen,701,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""stat: {"");\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', ""                buf[pos - 1] = '}';\n"", '                memset(buf, 0, BUF_SIZE);\n', '        size_t pos = strlen(buf);\n', '        if (pos > 7) {\n', ""            buf[pos - 1] = '}';\n"", 'else\n', ""            buf[pos] = '}';\n"", '            pos++;\n']","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC1(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
int  Var8=FUNC3(Var1,STRUCT4); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
char *Var10=STRUCT4->Var10  STRUCT4->Var10  Var1->memberVar1; 
size_t  Var11=strlen(Var5); 
size_t  Var12=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); 
size_t  Var11=strlen(Var5); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
else 
}else if (strcmp(Var7,STRING) == 0){
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
sprintf(Var5,STRING); 
while ((Var9=FUNC4(&Var13)) != NULL ){
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
size_t  Var11=strlen(Var5); 
if (Var11>Var6/2){
Var5[Var11-1]=}; 
memset(Var5,0,Var6); 
size_t  Var11=strlen(Var5); 
if (Var11>7){
Var5[Var11-1]=}; 
else 
Var5[Var11]=}; 
Var11  Var14; 
",572,0
manager.c,manager_recv_cb,False,False,110,CWE-,CallExpression,sendto,704,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    len = sizeof(struct sockaddr_un);\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n', '        int ret = add_server(manager, server);\n', '        char *msg;\n', '        int msg_len;\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0) {\n', '        char msg[3] = ""ok"";\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""stat: {"");\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', ""                buf[pos - 1] = '}';\n"", '                memset(buf, 0, BUF_SIZE);\n', '        size_t pos = strlen(buf);\n', '        if (pos > 7) {\n', ""            buf[pos - 1] = '}';\n"", 'else\n', ""            buf[pos] = '}';\n"", '            pos++;\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
STRUCT5  Var5; 
char  Var6[Var7]; 
Var4=sizeof (struct  Var8); 
Var5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); 
if (Var5 == -1){
if (Var5>Var7/2){
char *Var10=FUNC2(Var6,Var5); 
if (Var10 == NULL ){
if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){
int  Var11=FUNC4(Var3,STRUCT7); 
char *Var12; 
int  Var13; 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
while ((Var14=FUNC5(&Var15)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
char *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; 
size_t  Var17=strlen(Var6); 
size_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); 
if (Var17>Var7-Var18-50){
size_t  Var17=strlen(Var6); 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){
char  Var12[3]=STRING; 
else 
}else if (strcmp(Var10,STRING) == 0){
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
memset(Var6,0,Var7); 
sprintf(Var6,STRING); 
while ((Var14=FUNC5(&Var19)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
size_t  Var17=strlen(Var6); 
if (Var17>Var7/2){
Var6[Var17-1]=}; 
memset(Var6,0,Var7); 
size_t  Var17=strlen(Var6); 
if (Var17>7){
Var6[Var17-1]=}; 
else 
Var6[Var17]=}; 
Var17  Var20; 
",766,0
manager.c,manager_recv_cb,False,False,111,CWE-,CallExpression,memset,708,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""stat: {"");\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', ""                buf[pos - 1] = '}';\n"", '                memset(buf, 0, BUF_SIZE);\n', '        size_t pos = strlen(buf);\n', '        if (pos > 7) {\n', ""            buf[pos - 1] = '}';\n"", 'else\n', ""            buf[pos] = '}';\n""]","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC1(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
int  Var8=FUNC3(Var1,STRUCT4); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
char *Var10=STRUCT4->Var10  STRUCT4->Var10  Var1->memberVar1; 
size_t  Var11=strlen(Var5); 
size_t  Var12=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); 
size_t  Var11=strlen(Var5); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
else 
}else if (strcmp(Var7,STRING) == 0){
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
sprintf(Var5,STRING); 
while ((Var9=FUNC4(&Var13)) != NULL ){
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
size_t  Var11=strlen(Var5); 
if (Var11>Var6/2){
Var5[Var11-1]=}; 
memset(Var5,0,Var6); 
size_t  Var11=strlen(Var5); 
if (Var11>7){
Var5[Var11-1]=}; 
else 
Var5[Var11]=}; 
",565,0
manager.c,manager_recv_cb,False,False,112,CWE-,CallExpression,strlen,714,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""stat: {"");\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', ""                buf[pos - 1] = '}';\n"", '                memset(buf, 0, BUF_SIZE);\n', '        size_t pos = strlen(buf);\n', '        if (pos > 7) {\n', ""            buf[pos - 1] = '}';\n"", 'else\n', ""            buf[pos] = '}';\n"", '            pos++;\n']","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var7=FUNC1(Var5,Var4); 
if (Var7 == NULL ){
if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
int  Var8=FUNC3(Var1,STRUCT4); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
char *Var10=STRUCT4->Var10  STRUCT4->Var10  Var1->memberVar1; 
size_t  Var11=strlen(Var5); 
size_t  Var12=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); 
size_t  Var11=strlen(Var5); 
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); 
else 
}else if (strcmp(Var7,STRING) == 0){
else 
}else if (strcmp(Var7,STRING) == 0){
struct STRUCT5 *Var9; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
sprintf(Var5,STRING); 
while ((Var9=FUNC4(&Var13)) != NULL ){
struct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; 
size_t  Var11=strlen(Var5); 
if (Var11>Var6/2){
Var5[Var11-1]=}; 
memset(Var5,0,Var6); 
size_t  Var11=strlen(Var5); 
if (Var11>7){
Var5[Var11-1]=}; 
else 
Var5[Var11]=}; 
Var11  Var14; 
",572,0
manager.c,manager_recv_cb,False,False,113,CWE-,CallExpression,sendto,722,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    len = sizeof(struct sockaddr_un);\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n', '        int ret = add_server(manager, server);\n', '        char *msg;\n', '        int msg_len;\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0) {\n', '        char msg[3] = ""ok"";\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        memset(buf, 0, BUF_SIZE);\n', '        sprintf(buf, ""stat: {"");\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', ""                buf[pos - 1] = '}';\n"", '                memset(buf, 0, BUF_SIZE);\n', '        size_t pos = strlen(buf);\n', '        if (pos > 7) {\n', ""            buf[pos - 1] = '}';\n"", 'else\n', ""            buf[pos] = '}';\n"", '            pos++;\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
STRUCT5  Var5; 
char  Var6[Var7]; 
Var4=sizeof (struct  Var8); 
Var5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); 
if (Var5 == -1){
if (Var5>Var7/2){
char *Var10=FUNC2(Var6,Var5); 
if (Var10 == NULL ){
if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){
int  Var11=FUNC4(Var3,STRUCT7); 
char *Var12; 
int  Var13; 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
while ((Var14=FUNC5(&Var15)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
char *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; 
size_t  Var17=strlen(Var6); 
size_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); 
if (Var17>Var7-Var18-50){
size_t  Var17=strlen(Var6); 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){
char  Var12[3]=STRING; 
else 
}else if (strcmp(Var10,STRING) == 0){
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
memset(Var6,0,Var7); 
sprintf(Var6,STRING); 
while ((Var14=FUNC5(&Var19)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
size_t  Var17=strlen(Var6); 
if (Var17>Var7/2){
Var6[Var17-1]=}; 
memset(Var6,0,Var7); 
size_t  Var17=strlen(Var6); 
if (Var17>7){
Var6[Var17-1]=}; 
else 
Var6[Var17]=}; 
Var17  Var20; 
",766,0
manager.c,manager_recv_cb,False,False,114,CWE-,CallExpression,strcpy,731,-3,"['    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    memset(buf, 0, BUF_SIZE);\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n', '            LOGE(""invalid command: %s:%s"", buf, get_data(buf, r));\n', '        int ret = add_server(manager, server);\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0) {\n', '            LOGE(""invalid command: %s:%s"", buf, get_data(buf, r));\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', '        char port[8];\n', '        if (parse_traffic(buf, r, port, &traffic) == -1) {\n', '            LOGE(""invalid command: %s:%s"", buf, get_data(buf, r));\n', '        char buf[BUF_SIZE];\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '        size_t pos = strlen(buf);\n', '    strcpy(buf, ""err"");\n']","struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; 
STRUCT2  Var3; 
STRUCT3  Var4; 
char  Var5[Var6]; 
memset(Var5,0,Var6); 
Var4=recvfrom(Var1->memberVar1,Var5,Var6,0,(struct STRUCT4 *)&Var7,&Var3); 
if (Var4 == -1){
if (Var4>Var6/2){
char *Var8=FUNC1(Var5,Var4); 
if (Var8 == NULL ){
if (strcmp(Var8,STRING) == 0){
struct STRUCT5 *STRUCT5=FUNC2(Var5,Var4); 
if (STRUCT5 == NULL ||STRUCT5->memberVar1[0]== 0||STRUCT5->memberVar2[0]== 0){
FUNC3(STRING,Var5,FUNC4(Var5,Var4)); 
int  Var9=FUNC5(Var1,STRUCT5); 
else 
}else if (strcmp(Var8,STRING) == 0){
char  Var5[Var6]; 
struct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var10->memberVar1; 
char *Var11=STRUCT5->Var11  STRUCT5->Var11  Var1->memberVar2; 
size_t  Var12=strlen(Var5); 
size_t  Var13=strlen(STRUCT5->memberVar1)+strlen(STRUCT5->memberVar2)+strlen(memberVar2); 
size_t  Var12=strlen(Var5); 
else 
}else if (strcmp(Var8,STRING) == 0){
struct STRUCT5 *STRUCT5=FUNC2(Var5,Var4); 
if (STRUCT5 == NULL ||STRUCT5->memberVar1[0]== 0){
FUNC3(STRING,Var5,FUNC4(Var5,Var4)); 
else 
}else if (strcmp(Var8,STRING) == 0){
char  memberVar1[8]; 
if (FUNC6(Var5,Var4,memberVar1,&Var14) == -1){
FUNC3(STRING,Var5,FUNC4(Var5,Var4)); 
char  Var5[Var6]; 
struct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var10->memberVar1; 
size_t  Var12=strlen(Var5); 
size_t  Var12=strlen(Var5); 
strcpy(Var5,STRING); 
",625,0
manager.c,manager_recv_cb,False,False,115,CWE-,CallExpression,sendto,732,-3,"['manager_recv_cb(EV_P_ ev_io *w, int revents)\n', '    struct manager_ctx *manager = (struct manager_ctx *)w;\n', '    socklen_t len;\n', '    ssize_t r;\n', '    char buf[BUF_SIZE];\n', '    memset(buf, 0, BUF_SIZE);\n', '    len = sizeof(struct sockaddr_un);\n', '    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n', '    if (r == -1) {\n', '    if (r > BUF_SIZE / 2) {\n', '    char *action = get_action(buf, r);\n', '    if (action == NULL) {\n', '    if (strcmp(action, ""add"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n', '            LOGE(""invalid command: %s:%s"", buf, get_data(buf, r));\n', '        int ret = add_server(manager, server);\n', '        char *msg;\n', '        int msg_len;\n', 'else\n', '    } else if (strcmp(action, ""list"") == 0) {\n', '        struct cork_hash_table_entry  *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            char *method = server->method?server->method:manager->method;\n', '            size_t pos = strlen(buf);\n', '            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n', '            if (pos > BUF_SIZE-entry_len-50) {\n', '        size_t pos = strlen(buf);\n', 'else\n', '    } else if (strcmp(action, ""remove"") == 0) {\n', '        struct server *server = get_server(buf, r);\n', '        if (server == NULL || server->port[0] == 0) {\n', '            LOGE(""invalid command: %s:%s"", buf, get_data(buf, r));\n', '        char msg[3] = ""ok"";\n', 'else\n', '    } else if (strcmp(action, ""stat"") == 0) {\n', '        char port[8];\n', '        if (parse_traffic(buf, r, port, &traffic) == -1) {\n', '            LOGE(""invalid command: %s:%s"", buf, get_data(buf, r));\n', 'else\n', '    } else if (strcmp(action, ""ping"") == 0) {\n', '        struct cork_hash_table_entry *entry;\n', '        char buf[BUF_SIZE];\n', '        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '            struct server *server = (struct server *)entry->value;\n', '            size_t pos            = strlen(buf);\n', '            if (pos > BUF_SIZE / 2) {\n', '        size_t pos = strlen(buf);\n', '    strcpy(buf, ""err"");\n']","FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)
struct STRUCT3 *Var3=(struct STRUCT3 *) Var1; 
STRUCT4  Var4; 
STRUCT5  Var5; 
char  Var6[Var7]; 
memset(Var6,0,Var7); 
Var4=sizeof (struct  Var8); 
Var5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); 
if (Var5 == -1){
if (Var5>Var7/2){
char *Var10=FUNC2(Var6,Var5); 
if (Var10 == NULL ){
if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){
FUNC4(STRING,Var6,FUNC5(Var6,Var5)); 
int  Var11=FUNC6(Var3,STRUCT7); 
char *Var12; 
int  Var13; 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
while ((Var14=FUNC7(&Var15)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
char *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; 
size_t  Var17=strlen(Var6); 
size_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); 
if (Var17>Var7-Var18-50){
size_t  Var17=strlen(Var6); 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); 
if (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){
FUNC4(STRING,Var6,FUNC5(Var6,Var5)); 
char  Var12[3]=STRING; 
else 
}else if (strcmp(Var10,STRING) == 0){
char  memberVar1[8]; 
if (FUNC8(Var6,Var5,memberVar1,&Var19) == -1){
FUNC4(STRING,Var6,FUNC5(Var6,Var5)); 
else 
}else if (strcmp(Var10,STRING) == 0){
struct STRUCT8 *Var14; 
char  Var6[Var7]; 
while ((Var14=FUNC7(&Var20)) != NULL ){
struct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; 
size_t  Var17=strlen(Var6); 
if (Var17>Var7/2){
size_t  Var17=strlen(Var6); 
strcpy(Var6,STRING); 
",797,0
manager.c,create_server_socket,False,False,116,CWE-,CallExpression,memset,756,-3,"['    memset(&hints, 0, sizeof(struct addrinfo));\n']","memset(&Var1,0,sizeof (struct  Var2)); 
",18,0
manager.c,create_server_socket,False,False,117,CWE-,CallExpression,getaddrinfo,762,-3,"['create_server_socket(const char *host, const char *port)\n', '    struct addrinfo *result, *rp, *ipv4v6bindall;\n', '    int s, server_sock;\n', '    s = getaddrinfo(host, port, &hints, &result);\n', '    if (s != 0) {\n', '        LOGE(""getaddrinfo: %s"", gai_strerror(s));\n', '    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n', '        if (server_sock == -1) {\n', '        if (rp->ai_family == AF_INET6) {\n', '            int ipv6only = host ? 1 : 0;\n', '        if (s == 0) {\n']","FUNC1(const char *Var1,const char *Var2)
struct STRUCT1 *Var3,*Var4,*Var5; 
int  Var6,Var7; 
Var6=getaddrinfo(Var1,Var2,&Var8,&Var3); 
if (Var6 != 0){
FUNC2(STRING,FUNC3(Var6)); 
for (/*Var4=Var3 */; Var4 != NULL ; Var4=Var4->memberVar1){
if (Var7 == -1){
if (Var4->memberVar2 ==  Var9){
int  Var10=Var1 10; 
if (Var6 == 0){
",177,0
manager.c,create_server_socket,False,False,118,CWE-,CallExpression,socket,790,-3,"['    struct addrinfo *result, *rp, *ipv4v6bindall;\n', '    int s, server_sock;\n', '    if (s != 0) {\n', '    rp = result;\n', '    if (!host) {\n', '        ipv4v6bindall = result;\n', '        while (ipv4v6bindall) {\n', '            if (ipv4v6bindall->ai_family == AF_INET6) {\n', '                rp = ipv4v6bindall; /* Take first IPV6 address available */\n', '            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n', '    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n', '        server_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n', '        if (server_sock == -1) {\n', '        if (rp->ai_family == AF_INET6) {\n', '            int ipv6only = host ? 1 : 0;\n', '            setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n', '        setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n', '        s = bind(server_sock, rp->ai_addr, rp->ai_addrlen);\n', '        if (s == 0) {\n', '        close(server_sock);\n', '    if (rp == NULL) {\n', '    return server_sock;\n']","struct STRUCT1 *Var1,*Var2,*Var3; 
int  Var4,Var5; 
if (Var4 != 0){
Var2=Var1; 
if (!Var6){
Var3=Var1; 
while (Var3){
if (Var3->memberVar1 ==  Var7){
Var2=Var3; /*Var8  Var9  Var10  STRUCT2 STRUCT3 */
Var3=Var3->memberVar2; /*Var11  Var12  STRUCT2  Var13,if STRUCT4 */
for (/*Var2=Var1 */; Var2 != NULL ; Var2=Var2->memberVar1){
Var5=socket(Var2->memberVar2,Var2->memberVar3,Var2->memberVar4); 
if (Var5 == -1){
if (Var2->memberVar2 ==  Var7){
int  Var14=Var6 10; 
FUNC1(Var5,Var15,Var16,&Var14,sizeof (Var14)); 
FUNC1(Var5,Var17,Var18,&Var19,sizeof (Var19)); 
Var4=FUNC2(Var5,Var2->memberVar5,Var2->memberVar6); 
if (Var4 == 0){
close(Var5); 
if (Var2 == NULL ){
return  Var5; 
",352,0
manager.c,create_server_socket,False,False,119,CWE-,CallExpression,close,811,-3,"['    struct addrinfo *result, *rp, *ipv4v6bindall;\n', '    int s, server_sock;\n', '    if (s != 0) {\n', '    rp = result;\n', '    if (!host) {\n', '        ipv4v6bindall = result;\n', '        while (ipv4v6bindall) {\n', '            if (ipv4v6bindall->ai_family == AF_INET6) {\n', '                rp = ipv4v6bindall; /* Take first IPV6 address available */\n', '            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n', '    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n', '        server_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n', '        if (server_sock == -1) {\n', '        if (rp->ai_family == AF_INET6) {\n', '            int ipv6only = host ? 1 : 0;\n', '            setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n', '        setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n', '        s = bind(server_sock, rp->ai_addr, rp->ai_addrlen);\n', '        if (s == 0) {\n', '        close(server_sock);\n', '    if (rp == NULL) {\n', '    return server_sock;\n']","struct STRUCT1 *Var1,*Var2,*Var3; 
int  Var4,Var5; 
if (Var4 != 0){
Var2=Var1; 
if (!Var6){
Var3=Var1; 
while (Var3){
if (Var3->memberVar1 ==  Var7){
Var2=Var3; /*Var8  Var9  Var10  STRUCT2 STRUCT3 */
Var3=Var3->memberVar2; /*Var11  Var12  STRUCT2  Var13,if STRUCT4 */
for (/*Var2=Var1 */; Var2 != NULL ; Var2=Var2->memberVar1){
Var5=socket(Var2->memberVar2,Var2->memberVar3,Var2->memberVar4); 
if (Var5 == -1){
if (Var2->memberVar2 ==  Var7){
int  Var14=Var6 10; 
FUNC1(Var5,Var15,Var16,&Var14,sizeof (Var14)); 
FUNC1(Var5,Var17,Var18,&Var19,sizeof (Var19)); 
Var4=FUNC2(Var5,Var2->memberVar5,Var2->memberVar6); 
if (Var4 == 0){
close(Var5); 
if (Var2 == NULL ){
return  Var5; 
",352,0
manager.c,main,False,False,120,CWE-,CallExpression,getopt_long,879,-3,"['main(int argc, char **argv)\n', '    int i, c;\n', '    int pid_flags         = 0;\n', '    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    int server_num = 0;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    while ((c = getopt_long(argc, argv, ""f:s:l:k:t:m:c:i:d:a:n:6huUvA"",\n                            long_options, NULL)) != -1)\n', '    if (conf_path != NULL) {\n', '    USE_SYSLOG(argv[0], pid_flags);\n', '    DIR *dp;\n', '    struct dirent *ep;\n', '    if (dp != NULL) {\n', '        while ((ep = readdir(dp)) != NULL) {\n', '            size_t len = strlen(ep->d_name);\n', '    struct cork_hash_table_entry *entry;\n', '    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '        struct server *server = (struct server *)entry->value;\n']","main(int  Var1,char **Var2)
int  Var3,Var4; 
int  Var5=0; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
char *Var12=NULL ; 
char *Var13=NULL ; 
char *Var14=NULL ; 
char *Var15=NULL ; 
char *Var16=NULL ; 
int  Var17=0; 
STRUCT1 *Var18=NULL ; 
static struct  STRUCT2  Var19[]={
while ((Var4=getopt_long(Var1,Var2,STRING,
Var19,NULL )) != -1)
if (Var12 != NULL ){
FUNC1(Var2[0],Var5); 
STRUCT3 *Var20; 
struct STRUCT4 *Var21; 
if (Var20 != NULL ){
while ((Var21=FUNC2(Var20)) != NULL ){
size_t  Var22=strlen(Var21->memberVar1); 
struct STRUCT5 *Var23; 
while ((Var23=FUNC3(&Var24)) != NULL ){
struct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var23->memberVar1; 
",359,0
manager.c,main,False,False,121,CWE-,CallExpression,atoi,898,-3,"['    int i, c;\n', '    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    int mtu        = 0;\n', '    int ipv6first  = 0;\n', '    static int nofile = 0;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    while ((c = getopt_long(argc, argv, ""f:s:l:k:t:m:c:i:d:a:n:6huUvA"",\n                            long_options, NULL)) != -1)\n', '        switch (c) {\n', '            mtu = atoi(optarg);\n', '    if (conf_path != NULL) {\n', '    struct manager_ctx manager;\n', '    manager.mtu             = mtu;\n', '    manager.plugin          = plugin;\n', '    manager.plugin_opts     = plugin_opts;\n', '    manager.ipv6first       = ipv6first;\n', '    manager.nofile = nofile;\n', '    struct ev_loop *loop = EV_DEFAULT;\n', '    int sfd;\n', '    manager.fd = sfd;\n', '    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n', '    ev_io_start(loop, &manager.io);\n']","int  Var1,Var2; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
char *Var12=NULL ; 
char *Var13=NULL ; 
int  Var14=0; 
int  Var15=0; 
static int  Var16=0; 
STRUCT1 *Var17=NULL ; 
static struct  STRUCT2  Var18[]={
while ((Var2=getopt_long(Var19,Var20,STRING,
Var18,NULL )) != -1)
switch (Var2){
Var14=FUNC1(Var21); 
if (Var9 != NULL ){
struct  STRUCT3  Var22; 
Var22.memberVar1=memberVar1; 
Var22.memberVar2=memberVar2; 
Var22.memberVar3=memberVar3; 
Var22.memberVar4=memberVar4; 
Var22.memberVar5=memberVar5; 
struct STRUCT4 *Var23=Var24; 
int  Var25; 
Var22.memberVar6=Var25; 
FUNC2(&Var22.memberVar7,Var26,Var22.memberVar6,Var27); 
FUNC3(Var23,&Var22.memberVar7); 
",360,0
manager.c,main,False,False,122,CWE-,CallExpression,atoi,957,-3,"['    int i, c;\n', '    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    static int nofile = 0;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    while ((c = getopt_long(argc, argv, ""f:s:l:k:t:m:c:i:d:a:n:6huUvA"",\n                            long_options, NULL)) != -1)\n', '        switch (c) {\n', '            nofile = atoi(optarg);\n', '    if (conf_path != NULL) {\n', '    struct manager_ctx manager;\n', '    manager.nofile = nofile;\n', '    struct ev_loop *loop = EV_DEFAULT;\n', '    int sfd;\n', '    manager.fd = sfd;\n', '    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n', '    ev_io_start(loop, &manager.io);\n']","int  Var1,Var2; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
char *Var12=NULL ; 
char *Var13=NULL ; 
static int  Var14=0; 
STRUCT1 *Var15=NULL ; 
static struct  STRUCT2  Var16[]={
while ((Var2=getopt_long(Var17,Var18,STRING,
Var16,NULL )) != -1)
switch (Var2){
Var14=FUNC1(Var19); 
if (Var9 != NULL ){
struct  STRUCT3  Var20; 
Var20.memberVar1=memberVar1; 
struct STRUCT4 *Var21=Var22; 
int  Var23; 
Var20.memberVar2=Var23; 
FUNC2(&Var20.memberVar3,Var24,Var20.memberVar2,Var25); 
FUNC3(Var21,&Var20.memberVar3); 
",304,0
manager.c,main,False,False,123,CWE-,CallExpression,signal,1061,-3,"['    signal(SIGPIPE, SIG_IGN);\n']","signal(Var1,Var2); 
",9,0
manager.c,main,False,False,124,CWE-,CallExpression,signal,1062,-3,"['    signal(SIGCHLD, SIG_IGN);\n']","signal(Var1,Var2); 
",9,0
manager.c,main,False,False,125,CWE-,CallExpression,signal,1063,-3,"['    signal(SIGABRT, SIG_IGN);\n']","signal(Var1,Var2); 
",9,0
manager.c,main,False,False,126,CWE-,CallExpression,memset,1073,-3,"['    memset(&manager, 0, sizeof(struct manager_ctx));\n']","memset(&Var1,0,sizeof (struct  Var2)); 
",18,0
manager.c,main,False,False,127,CWE-,CallExpression,getpwuid,1105,-3,"['    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    struct passwd *pw   = getpwuid(getuid());\n', '    const char *homedir = pw->pw_dir;\n', '    working_dir_size = strlen(homedir) + 15;\n', '    working_dir      = ss_malloc(working_dir_size);\n', '    snprintf(working_dir, working_dir_size, ""%s/.shadowsocks"", homedir);\n', '    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n', '    if (err != 0 && errno != EEXIST) {\n', '        ss_free(working_dir);\n', '    DIR *dp;\n', '    struct dirent *ep;\n', '    dp = opendir(working_dir);\n', '    if (dp != NULL) {\n', '        while ((ep = readdir(dp)) != NULL) {\n', '            size_t len = strlen(ep->d_name);\n', '            if (strcmp(ep->d_name + len - 3, ""pid"") == 0) {\n', '                kill_server(working_dir, ep->d_name);\n', '                if (verbose)\n', '                    LOGI(""kill %s"", ep->d_name);\n', '        closedir(dp);\n', 'else\n', '        ss_free(working_dir);\n', '            struct server *server = ss_malloc(sizeof(struct server));\n', '    int sfd;\n', '    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n', '        if (sfd == -1) {\n', '            ss_free(working_dir);\n', '        if (remove(manager_address) == -1 && errno != ENOENT) {\n', '            ss_free(working_dir);\n', '        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n', '            ss_free(working_dir);\n', '        if (sfd == -1) {\n', '            ss_free(working_dir);\n', '    struct cork_hash_table_entry *entry;\n', '    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '        struct server *server = (struct server *)entry->value;\n', '        stop_server(working_dir, server->port);\n', '    ss_free(working_dir);\n']","char *Var1=NULL ; 
char *Var2=NULL ; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT1 *Var12=NULL ; 
static struct  STRUCT2  Var13[]={
struct STRUCT3 *Var14=getpwuid(FUNC1()); 
const char *Var15=Var14->memberVar1; 
Var16=strlen(Var15)+15; 
Var17=FUNC2(Var16); 
snprintf(Var17,Var16,STRING,Var15); 
int  Var18=mkdir(Var17,Var19|Var20|Var21|Var22); 
if (Var18 != 0&&Var23 !=  Var24){
FUNC3(Var17); 
STRUCT4 *Var25; 
struct STRUCT5 *Var26; 
Var25=FUNC4(Var17); 
if (Var25 != NULL ){
while ((Var26=FUNC5(Var25)) != NULL ){
size_t  Var27=strlen(Var26->memberVar1); 
if (strcmp(Var26->memberVar1+Var27-3,STRING) == 0){
FUNC6(Var17,Var26->memberVar1); 
if (Var28)
FUNC7(STRING,Var26->memberVar1); 
FUNC8(Var25); 
else 
FUNC3(Var17); 
struct STRUCT6 *STRUCT6=FUNC2(sizeof (struct  STRUCT6)); 
int  Var29; 
if (Var30.memberVar1 == NULL ||Var30.memberVar2 == NULL ){
if (Var29 == -1){
FUNC3(Var17); 
if (remove(Var9) == -1&&Var23 !=  Var31){
FUNC3(Var17); 
if (FUNC9(Var29,(struct STRUCT7 *)&Var32,sizeof (struct  Var33)) == -1){
FUNC3(Var17); 
if (Var29 == -1){
FUNC3(Var17); 
struct STRUCT8 *Var34; 
while ((Var34=FUNC10(&Var35)) != NULL ){
struct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var34->memberVar1; 
FUNC11(Var17,STRUCT6->memberVar1); 
FUNC3(Var17); 
",670,0
manager.c,main,False,False,128,CWE-,CallExpression,strlen,1107,-3,"['    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    struct passwd *pw   = getpwuid(getuid());\n', '    const char *homedir = pw->pw_dir;\n', '    working_dir_size = strlen(homedir) + 15;\n', '    working_dir      = ss_malloc(working_dir_size);\n', '    snprintf(working_dir, working_dir_size, ""%s/.shadowsocks"", homedir);\n', '    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n', '    if (err != 0 && errno != EEXIST) {\n', '        ss_free(working_dir);\n', '    DIR *dp;\n', '    struct dirent *ep;\n', '    dp = opendir(working_dir);\n', '    if (dp != NULL) {\n', '        while ((ep = readdir(dp)) != NULL) {\n', '            size_t len = strlen(ep->d_name);\n', '            if (strcmp(ep->d_name + len - 3, ""pid"") == 0) {\n', '                kill_server(working_dir, ep->d_name);\n', '                if (verbose)\n', '                    LOGI(""kill %s"", ep->d_name);\n', '        closedir(dp);\n', 'else\n', '        ss_free(working_dir);\n', '            struct server *server = ss_malloc(sizeof(struct server));\n', '    int sfd;\n', '    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n', '        if (sfd == -1) {\n', '            ss_free(working_dir);\n', '        if (remove(manager_address) == -1 && errno != ENOENT) {\n', '            ss_free(working_dir);\n', '        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n', '            ss_free(working_dir);\n', '        if (sfd == -1) {\n', '            ss_free(working_dir);\n', '    struct cork_hash_table_entry *entry;\n', '    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '        struct server *server = (struct server *)entry->value;\n', '        stop_server(working_dir, server->port);\n', '    ss_free(working_dir);\n']","char *Var1=NULL ; 
char *Var2=NULL ; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT1 *Var12=NULL ; 
static struct  STRUCT2  Var13[]={
struct STRUCT3 *Var14=getpwuid(FUNC1()); 
const char *Var15=Var14->memberVar1; 
Var16=strlen(Var15)+15; 
Var17=FUNC2(Var16); 
snprintf(Var17,Var16,STRING,Var15); 
int  Var18=mkdir(Var17,Var19|Var20|Var21|Var22); 
if (Var18 != 0&&Var23 !=  Var24){
FUNC3(Var17); 
STRUCT4 *Var25; 
struct STRUCT5 *Var26; 
Var25=FUNC4(Var17); 
if (Var25 != NULL ){
while ((Var26=FUNC5(Var25)) != NULL ){
size_t  Var27=strlen(Var26->memberVar1); 
if (strcmp(Var26->memberVar1+Var27-3,STRING) == 0){
FUNC6(Var17,Var26->memberVar1); 
if (Var28)
FUNC7(STRING,Var26->memberVar1); 
FUNC8(Var25); 
else 
FUNC3(Var17); 
struct STRUCT6 *STRUCT6=FUNC2(sizeof (struct  STRUCT6)); 
int  Var29; 
if (Var30.memberVar1 == NULL ||Var30.memberVar2 == NULL ){
if (Var29 == -1){
FUNC3(Var17); 
if (remove(Var9) == -1&&Var23 !=  Var31){
FUNC3(Var17); 
if (FUNC9(Var29,(struct STRUCT7 *)&Var32,sizeof (struct  Var33)) == -1){
FUNC3(Var17); 
if (Var29 == -1){
FUNC3(Var17); 
struct STRUCT8 *Var34; 
while ((Var34=FUNC10(&Var35)) != NULL ){
struct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var34->memberVar1; 
FUNC11(Var17,STRUCT6->memberVar1); 
FUNC3(Var17); 
",670,0
manager.c,main,False,False,129,CWE-,CallExpression,snprintf,1109,-3,"['    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    struct passwd *pw   = getpwuid(getuid());\n', '    const char *homedir = pw->pw_dir;\n', '    working_dir_size = strlen(homedir) + 15;\n', '    working_dir      = ss_malloc(working_dir_size);\n', '    snprintf(working_dir, working_dir_size, ""%s/.shadowsocks"", homedir);\n', '    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n', '    if (err != 0 && errno != EEXIST) {\n', '        ss_free(working_dir);\n', '    DIR *dp;\n', '    struct dirent *ep;\n', '    dp = opendir(working_dir);\n', '    if (dp != NULL) {\n', '        while ((ep = readdir(dp)) != NULL) {\n', '            size_t len = strlen(ep->d_name);\n', '            if (strcmp(ep->d_name + len - 3, ""pid"") == 0) {\n', '                kill_server(working_dir, ep->d_name);\n', 'else\n', '        ss_free(working_dir);\n', '            struct server *server = ss_malloc(sizeof(struct server));\n', '    int sfd;\n', '    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n', '        if (sfd == -1) {\n', '            ss_free(working_dir);\n', '        if (remove(manager_address) == -1 && errno != ENOENT) {\n', '            ss_free(working_dir);\n', '        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n', '            ss_free(working_dir);\n', '        if (sfd == -1) {\n', '            ss_free(working_dir);\n', '    struct cork_hash_table_entry *entry;\n', '    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '        struct server *server = (struct server *)entry->value;\n', '        stop_server(working_dir, server->port);\n', '    ss_free(working_dir);\n']","char *Var1=NULL ; 
char *Var2=NULL ; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT1 *Var12=NULL ; 
static struct  STRUCT2  Var13[]={
struct STRUCT3 *Var14=getpwuid(FUNC1()); 
const char *Var15=Var14->memberVar1; 
Var16=strlen(Var15)+15; 
Var17=FUNC2(Var16); 
snprintf(Var17,Var16,STRING,Var15); 
int  Var18=mkdir(Var17,Var19|Var20|Var21|Var22); 
if (Var18 != 0&&Var23 !=  Var24){
FUNC3(Var17); 
STRUCT4 *Var25; 
struct STRUCT5 *Var26; 
Var25=FUNC4(Var17); 
if (Var25 != NULL ){
while ((Var26=FUNC5(Var25)) != NULL ){
size_t  Var27=strlen(Var26->memberVar1); 
if (strcmp(Var26->memberVar1+Var27-3,STRING) == 0){
FUNC6(Var17,Var26->memberVar1); 
else 
FUNC3(Var17); 
struct STRUCT6 *STRUCT6=FUNC2(sizeof (struct  STRUCT6)); 
int  Var28; 
if (Var29.memberVar1 == NULL ||Var29.memberVar2 == NULL ){
if (Var28 == -1){
FUNC3(Var17); 
if (remove(Var9) == -1&&Var23 !=  Var30){
FUNC3(Var17); 
if (FUNC7(Var28,(struct STRUCT7 *)&Var31,sizeof (struct  Var32)) == -1){
FUNC3(Var17); 
if (Var28 == -1){
FUNC3(Var17); 
struct STRUCT8 *Var33; 
while ((Var33=FUNC8(&Var34)) != NULL ){
struct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var33->memberVar1; 
FUNC9(Var17,STRUCT6->memberVar1); 
FUNC3(Var17); 
",642,0
manager.c,main,False,False,130,CWE-,CallExpression,mkdir,1111,-3,"['    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    struct passwd *pw   = getpwuid(getuid());\n', '    const char *homedir = pw->pw_dir;\n', '    working_dir_size = strlen(homedir) + 15;\n', '    working_dir      = ss_malloc(working_dir_size);\n', '    snprintf(working_dir, working_dir_size, ""%s/.shadowsocks"", homedir);\n', '    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n', '    if (err != 0 && errno != EEXIST) {\n', '        ss_free(working_dir);\n', '    DIR *dp;\n', '    struct dirent *ep;\n', '    dp = opendir(working_dir);\n', '    if (dp != NULL) {\n', '        while ((ep = readdir(dp)) != NULL) {\n', '            size_t len = strlen(ep->d_name);\n', '            if (strcmp(ep->d_name + len - 3, ""pid"") == 0) {\n', '                kill_server(working_dir, ep->d_name);\n', 'else\n', '        ss_free(working_dir);\n', '            struct server *server = ss_malloc(sizeof(struct server));\n', '    int sfd;\n', '    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n', '        if (sfd == -1) {\n', '            ss_free(working_dir);\n', '        if (remove(manager_address) == -1 && errno != ENOENT) {\n', '            ss_free(working_dir);\n', '        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n', '            ss_free(working_dir);\n', '        if (sfd == -1) {\n', '            ss_free(working_dir);\n', '    struct cork_hash_table_entry *entry;\n', '    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n', '        struct server *server = (struct server *)entry->value;\n', '        stop_server(working_dir, server->port);\n', '    ss_free(working_dir);\n']","char *Var1=NULL ; 
char *Var2=NULL ; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT1 *Var12=NULL ; 
static struct  STRUCT2  Var13[]={
struct STRUCT3 *Var14=getpwuid(FUNC1()); 
const char *Var15=Var14->memberVar1; 
Var16=strlen(Var15)+15; 
Var17=FUNC2(Var16); 
snprintf(Var17,Var16,STRING,Var15); 
int  Var18=mkdir(Var17,Var19|Var20|Var21|Var22); 
if (Var18 != 0&&Var23 !=  Var24){
FUNC3(Var17); 
STRUCT4 *Var25; 
struct STRUCT5 *Var26; 
Var25=FUNC4(Var17); 
if (Var25 != NULL ){
while ((Var26=FUNC5(Var25)) != NULL ){
size_t  Var27=strlen(Var26->memberVar1); 
if (strcmp(Var26->memberVar1+Var27-3,STRING) == 0){
FUNC6(Var17,Var26->memberVar1); 
else 
FUNC3(Var17); 
struct STRUCT6 *STRUCT6=FUNC2(sizeof (struct  STRUCT6)); 
int  Var28; 
if (Var29.memberVar1 == NULL ||Var29.memberVar2 == NULL ){
if (Var28 == -1){
FUNC3(Var17); 
if (remove(Var9) == -1&&Var23 !=  Var30){
FUNC3(Var17); 
if (FUNC7(Var28,(struct STRUCT7 *)&Var31,sizeof (struct  Var32)) == -1){
FUNC3(Var17); 
if (Var28 == -1){
FUNC3(Var17); 
struct STRUCT8 *Var33; 
while ((Var33=FUNC8(&Var34)) != NULL ){
struct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var33->memberVar1; 
FUNC9(Var17,STRUCT6->memberVar1); 
FUNC3(Var17); 
",642,0
manager.c,main,False,False,131,CWE-,CallExpression,strlen,1124,-3,"['    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    struct passwd *pw   = getpwuid(getuid());\n', '    const char *homedir = pw->pw_dir;\n', '    working_dir_size = strlen(homedir) + 15;\n', '    working_dir      = ss_malloc(working_dir_size);\n', '    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n', '    DIR *dp;\n', '    struct dirent *ep;\n', '    dp = opendir(working_dir);\n', '    if (dp != NULL) {\n', '        while ((ep = readdir(dp)) != NULL) {\n', '            size_t len = strlen(ep->d_name);\n', '            if (strcmp(ep->d_name + len - 3, ""pid"") == 0) {\n', '                kill_server(working_dir, ep->d_name);\n', '                if (verbose)\n', '                    LOGI(""kill %s"", ep->d_name);\n', '            struct server *server = ss_malloc(sizeof(struct server));\n']","char *Var1=NULL ; 
char *Var2=NULL ; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT1 *Var12=NULL ; 
static struct  STRUCT2  Var13[]={
struct STRUCT3 *Var14=getpwuid(FUNC1()); 
const char *Var15=Var14->memberVar1; 
Var16=strlen(Var15)+15; 
Var17=FUNC2(Var16); 
int  Var18=mkdir(Var17,Var19|Var20|Var21|Var22); 
STRUCT4 *Var23; 
struct STRUCT5 *Var24; 
Var23=FUNC3(Var17); 
if (Var23 != NULL ){
while ((Var24=FUNC4(Var23)) != NULL ){
size_t  Var25=strlen(Var24->memberVar1); 
if (strcmp(Var24->memberVar1+Var25-3,STRING) == 0){
FUNC5(Var17,Var24->memberVar1); 
if (Var26)
FUNC6(STRING,Var24->memberVar1); 
struct STRUCT6 *STRUCT6=FUNC2(sizeof (struct  STRUCT6)); 
",374,0
manager.c,main,False,False,132,CWE-,CallExpression,strcmp,1125,-3,"['    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    struct passwd *pw   = getpwuid(getuid());\n', '    const char *homedir = pw->pw_dir;\n', '    working_dir_size = strlen(homedir) + 15;\n', '    working_dir      = ss_malloc(working_dir_size);\n', '    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n', '    DIR *dp;\n', '    struct dirent *ep;\n', '    dp = opendir(working_dir);\n', '    if (dp != NULL) {\n', '        while ((ep = readdir(dp)) != NULL) {\n', '            size_t len = strlen(ep->d_name);\n', '            if (strcmp(ep->d_name + len - 3, ""pid"") == 0) {\n', '                kill_server(working_dir, ep->d_name);\n', '                if (verbose)\n', '                    LOGI(""kill %s"", ep->d_name);\n', '            struct server *server = ss_malloc(sizeof(struct server));\n']","char *Var1=NULL ; 
char *Var2=NULL ; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT1 *Var12=NULL ; 
static struct  STRUCT2  Var13[]={
struct STRUCT3 *Var14=getpwuid(FUNC1()); 
const char *Var15=Var14->memberVar1; 
Var16=strlen(Var15)+15; 
Var17=FUNC2(Var16); 
int  Var18=mkdir(Var17,Var19|Var20|Var21|Var22); 
STRUCT4 *Var23; 
struct STRUCT5 *Var24; 
Var23=FUNC3(Var17); 
if (Var23 != NULL ){
while ((Var24=FUNC4(Var23)) != NULL ){
size_t  Var25=strlen(Var24->memberVar1); 
if (strcmp(Var24->memberVar1+Var25-3,STRING) == 0){
FUNC5(Var17,Var24->memberVar1); 
if (Var26)
FUNC6(STRING,Var24->memberVar1); 
struct STRUCT6 *STRUCT6=FUNC2(sizeof (struct  STRUCT6)); 
",374,0
manager.c,main,False,False,133,CWE-,CallExpression,memset,1142,-3,"['    int i, c;\n', '    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    if (conf != NULL) {\n', '        for (i = 0; i < conf->port_password_num; i++) {\n', '            struct server *server = ss_malloc(sizeof(struct server));\n', '            memset(server, 0, sizeof(struct server));\n', '            strncpy(server->port, conf->port_password[i].port, 8);\n', '            strncpy(server->password, conf->port_password[i].password, 128);\n', '            add_server(&manager, server);\n', '        struct server *server = (struct server *)entry->value;\n']","int  Var1,Var2; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT1 *Var14=NULL ; 
static struct  STRUCT2  Var15[]={
if (Var14 != NULL ){
for (Var1=0; Var1<Var14->memberVar1; Var1  Var16){
struct STRUCT3 *STRUCT3=FUNC1(sizeof (struct  STRUCT3)); 
memset(STRUCT3,0,sizeof (struct  STRUCT3)); 
strncpy(STRUCT3->memberVar1,Var14->memberVar2[Var1].memberVar1,8); 
strncpy(STRUCT3->memberVar2,Var14->memberVar2[Var1].memberVar2,128); 
FUNC2(&Var17,STRUCT3); 
struct STRUCT3 *STRUCT3=(struct STRUCT3 *) Var18->memberVar1; 
",311,0
manager.c,main,False,False,134,CWE-,CallExpression,strncpy,1143,-3,"['    int i, c;\n', '    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    int fast_open  = 0;\n', '    int reuse_port = 0;\n', '    int mode       = TCP_ONLY;\n', '    int mtu        = 0;\n', '    int ipv6first  = 0;\n', '    static int nofile = 0;\n', '    int server_num = 0;\n', '    char *server_host[MAX_REMOTE_NUM];\n', '    char *nameservers[MAX_DNS_NUM + 1];\n', '    int nameserver_num = 0;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    while ((c = getopt_long(argc, argv, ""f:s:l:k:t:m:c:i:d:a:n:6huUvA"",\n                            long_options, NULL)) != -1)\n', '        switch (c) {\n', '            conf_path = optarg;\n', '    if (conf_path != NULL) {\n', '        conf = read_jconf(conf_path);\n', '        if (server_num == 0) {\n', '            server_num = conf->remote_num;\n', '            for (i = 0; i < server_num; i++)\n', '                server_host[i] = conf->remote_addr[i].host;\n', '        if (password == NULL) {\n', '            password = conf->password;\n', '        if (method == NULL) {\n', '            method = conf->method;\n', '        if (timeout == NULL) {\n', '            timeout = conf->timeout;\n', '        if (user == NULL) {\n', '            user = conf->user;\n', '        if (fast_open == 0) {\n', '            fast_open = conf->fast_open;\n', '        if (reuse_port == 0) {\n', '            reuse_port = conf->reuse_port;\n', '        if (conf->nameserver != NULL) {\n', '            nameservers[nameserver_num++] = conf->nameserver;\n', '        if (mode == TCP_ONLY) {\n', '            mode = conf->mode;\n', '        if (mtu == 0) {\n', '            mtu = conf->mtu;\n', '        if (plugin == NULL) {\n', '            plugin = conf->plugin;\n', '        if (plugin_opts == NULL) {\n', '            plugin_opts = conf->plugin_opts;\n', '        if (ipv6first == 0) {\n', '            ipv6first = conf->ipv6_first;\n', '        if (nofile == 0) {\n', '            nofile = conf->nofile;\n', '    if (conf != NULL) {\n', '        for (i = 0; i < conf->port_password_num; i++) {\n', '            struct server *server = ss_malloc(sizeof(struct server));\n', '            memset(server, 0, sizeof(struct server));\n', '            strncpy(server->port, conf->port_password[i].port, 8);\n', '            strncpy(server->password, conf->port_password[i].password, 128);\n', '            add_server(&manager, server);\n', '        struct server *server = (struct server *)entry->value;\n']","int  Var1,Var2; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
char *Var12=NULL ; 
char *Var13=NULL ; 
int  Var14=0; 
int  Var15=0; 
int  Var16=Var17; 
int  Var18=0; 
int  Var19=0; 
static int  Var20=0; 
int  Var21=0; 
char *Var22[Var23]; 
char *Var24[Var25+1]; 
int  Var26=0; 
STRUCT1 *Var27=NULL ; 
static struct  STRUCT2  Var28[]={
while ((Var2=getopt_long(Var29,Var30,STRING,
Var28,NULL )) != -1)
switch (Var2){
Var9=Var31; 
if (Var9 != NULL ){
Var27=FUNC1(Var9); 
if (Var21 == 0){
Var21=Var27->memberVar1; 
for (Var1=0; Var1<Var21; Var1  Var32)
Var22[Var1]=Var27->memberVar2[Var1].memberVar1; 
if (Var5 == NULL ){
Var5=Var27->memberVar3; 
if (Var7 == NULL ){
Var7=Var27->memberVar4; 
if (Var6 == NULL ){
Var6=Var27->memberVar5; 
if (Var4 == NULL ){
Var4=Var27->memberVar6; 
if (Var14 == 0){
Var14=Var27->memberVar7; 
if (Var15 == 0){
Var15=Var27->memberVar8; 
if (Var27->memberVar9 != NULL ){
Var24[Var26  Var32]=Var27->memberVar9; 
if (Var16 ==  Var17){
Var16=Var27->memberVar10; 
if (Var18 == 0){
Var18=Var27->memberVar11; 
if (Var12 == NULL ){
Var12=Var27->memberVar12; 
if (Var13 == NULL ){
Var13=Var27->memberVar13; 
if (Var19 == 0){
Var19=Var27->memberVar14; 
if (Var20 == 0){
Var20=Var27->memberVar15; 
if (Var27 != NULL ){
for (Var1=0; Var1<Var27->memberVar16; Var1  Var32){
struct STRUCT3 *STRUCT3=FUNC2(sizeof (struct  STRUCT3)); 
memset(STRUCT3,0,sizeof (struct  STRUCT3)); 
strncpy(STRUCT3->memberVar1,Var27->memberVar17[Var1].memberVar2,8); 
strncpy(STRUCT3->memberVar2,Var27->memberVar17[Var1].memberVar3,128); 
FUNC3(&Var33,STRUCT3); 
struct STRUCT3 *STRUCT3=(struct STRUCT3 *) Var34->memberVar1; 
",837,0
manager.c,main,False,False,135,CWE-,CallExpression,strncpy,1144,-3,"['    int i, c;\n', '    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    int fast_open  = 0;\n', '    int reuse_port = 0;\n', '    int mode       = TCP_ONLY;\n', '    int mtu        = 0;\n', '    int ipv6first  = 0;\n', '    static int nofile = 0;\n', '    int server_num = 0;\n', '    char *server_host[MAX_REMOTE_NUM];\n', '    char *nameservers[MAX_DNS_NUM + 1];\n', '    int nameserver_num = 0;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    while ((c = getopt_long(argc, argv, ""f:s:l:k:t:m:c:i:d:a:n:6huUvA"",\n                            long_options, NULL)) != -1)\n', '        switch (c) {\n', '            conf_path = optarg;\n', '    if (conf_path != NULL) {\n', '        conf = read_jconf(conf_path);\n', '        if (server_num == 0) {\n', '            server_num = conf->remote_num;\n', '            for (i = 0; i < server_num; i++)\n', '                server_host[i] = conf->remote_addr[i].host;\n', '        if (password == NULL) {\n', '            password = conf->password;\n', '        if (method == NULL) {\n', '            method = conf->method;\n', '        if (timeout == NULL) {\n', '            timeout = conf->timeout;\n', '        if (user == NULL) {\n', '            user = conf->user;\n', '        if (fast_open == 0) {\n', '            fast_open = conf->fast_open;\n', '        if (reuse_port == 0) {\n', '            reuse_port = conf->reuse_port;\n', '        if (conf->nameserver != NULL) {\n', '            nameservers[nameserver_num++] = conf->nameserver;\n', '        if (mode == TCP_ONLY) {\n', '            mode = conf->mode;\n', '        if (mtu == 0) {\n', '            mtu = conf->mtu;\n', '        if (plugin == NULL) {\n', '            plugin = conf->plugin;\n', '        if (plugin_opts == NULL) {\n', '            plugin_opts = conf->plugin_opts;\n', '        if (ipv6first == 0) {\n', '            ipv6first = conf->ipv6_first;\n', '        if (nofile == 0) {\n', '            nofile = conf->nofile;\n', '    if (conf != NULL) {\n', '        for (i = 0; i < conf->port_password_num; i++) {\n', '            struct server *server = ss_malloc(sizeof(struct server));\n', '            memset(server, 0, sizeof(struct server));\n', '            strncpy(server->port, conf->port_password[i].port, 8);\n', '            strncpy(server->password, conf->port_password[i].password, 128);\n', '            add_server(&manager, server);\n', '        struct server *server = (struct server *)entry->value;\n']","int  Var1,Var2; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
char *Var12=NULL ; 
char *Var13=NULL ; 
int  Var14=0; 
int  Var15=0; 
int  Var16=Var17; 
int  Var18=0; 
int  Var19=0; 
static int  Var20=0; 
int  Var21=0; 
char *Var22[Var23]; 
char *Var24[Var25+1]; 
int  Var26=0; 
STRUCT1 *Var27=NULL ; 
static struct  STRUCT2  Var28[]={
while ((Var2=getopt_long(Var29,Var30,STRING,
Var28,NULL )) != -1)
switch (Var2){
Var9=Var31; 
if (Var9 != NULL ){
Var27=FUNC1(Var9); 
if (Var21 == 0){
Var21=Var27->memberVar1; 
for (Var1=0; Var1<Var21; Var1  Var32)
Var22[Var1]=Var27->memberVar2[Var1].memberVar1; 
if (Var5 == NULL ){
Var5=Var27->memberVar3; 
if (Var7 == NULL ){
Var7=Var27->memberVar4; 
if (Var6 == NULL ){
Var6=Var27->memberVar5; 
if (Var4 == NULL ){
Var4=Var27->memberVar6; 
if (Var14 == 0){
Var14=Var27->memberVar7; 
if (Var15 == 0){
Var15=Var27->memberVar8; 
if (Var27->memberVar9 != NULL ){
Var24[Var26  Var32]=Var27->memberVar9; 
if (Var16 ==  Var17){
Var16=Var27->memberVar10; 
if (Var18 == 0){
Var18=Var27->memberVar11; 
if (Var12 == NULL ){
Var12=Var27->memberVar12; 
if (Var13 == NULL ){
Var13=Var27->memberVar13; 
if (Var19 == 0){
Var19=Var27->memberVar14; 
if (Var20 == 0){
Var20=Var27->memberVar15; 
if (Var27 != NULL ){
for (Var1=0; Var1<Var27->memberVar16; Var1  Var32){
struct STRUCT3 *STRUCT3=FUNC2(sizeof (struct  STRUCT3)); 
memset(STRUCT3,0,sizeof (struct  STRUCT3)); 
strncpy(STRUCT3->memberVar1,Var27->memberVar17[Var1].memberVar2,8); 
strncpy(STRUCT3->memberVar2,Var27->memberVar17[Var1].memberVar3,128); 
FUNC3(&Var33,STRUCT3); 
struct STRUCT3 *STRUCT3=(struct STRUCT3 *) Var34->memberVar1; 
",837,0
manager.c,main,False,False,136,CWE-,CallExpression,socket,1155,-3,"['    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    struct manager_ctx manager;\n', '    struct ev_loop *loop = EV_DEFAULT;\n', '    int sfd;\n', '    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n', '        sfd = socket(AF_UNIX, SOCK_DGRAM, 0);       /*  Create server socket */\n', '        setnonblocking(sfd);\n', '    manager.fd = sfd;\n', '    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n', '    ev_io_start(loop, &manager.io);\n']","char *Var1=NULL ; 
char *Var2=NULL ; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT1 *Var12=NULL ; 
static struct  STRUCT2  Var13[]={
struct  STRUCT3  Var14; 
struct STRUCT4 *Var15=Var16; 
int  Var17; 
if (Var18.memberVar1 == NULL ||Var18.memberVar2 == NULL ){
Var17=socket(Var19,Var20,0); /*Var21  STRUCT5 socket*/
FUNC1(Var17); 
Var14.memberVar1=Var17; 
FUNC2(&Var14.memberVar2,Var22,Var14.memberVar1,Var23); 
FUNC3(Var15,&Var14.memberVar2); 
",274,0
manager.c,main,False,False,137,CWE-,CallExpression,remove,1163,-3,"['    int i, c;\n', '    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    int server_num = 0;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    while ((c = getopt_long(argc, argv, ""f:s:l:k:t:m:c:i:d:a:n:6huUvA"",\n                            long_options, NULL)) != -1)\n', '        switch (c) {\n', '            manager_address = optarg;\n', '    if (manager_address == NULL) {\n', '        manager_address = ""127.0.0.1:8839"";\n', '        LOGI(""using the default manager address: %s"", manager_address);\n', '    struct manager_ctx manager;\n', '    manager.manager_address = manager_address;\n', '    parse_addr(manager_address, &ip_addr);\n', '    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n', '        struct sockaddr_un svaddr;\n', '        strncpy(svaddr.sun_path, manager_address, sizeof(svaddr.sun_path) - 1);\n']","int  Var1,Var2; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
char *Var12=NULL ; 
char *Var13=NULL ; 
int  Var14=0; 
STRUCT1 *Var15=NULL ; 
static struct  STRUCT2  Var16[]={
while ((Var2=getopt_long(Var17,Var18,STRING,
Var16,NULL )) != -1)
switch (Var2){
Var11=Var19; 
if (Var11 == NULL ){
Var11=STRING; 
FUNC1(STRING,Var11); 
struct  STRUCT3  Var20; 
Var20.memberVar1=memberVar1; 
FUNC2(memberVar1,&Var21); 
if (Var21.memberVar1 == NULL ||Var21.memberVar2 == NULL ){
struct  STRUCT4  Var22; 
strncpy(Var22.memberVar1,memberVar1,sizeof (Var22.memberVar1)-1); 
",320,0
manager.c,main,False,False,138,CWE-,CallExpression,memset,1169,-3,"['    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n', '        memset(&svaddr, 0, sizeof(struct sockaddr_un));\n']","char *Var1=NULL ; 
char *Var2=NULL ; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT1 *Var12=NULL ; 
static struct  STRUCT2  Var13[]={
if (Var14.memberVar1 == NULL ||Var14.memberVar2 == NULL ){
memset(&Var15,0,sizeof (struct  Var16)); 
",181,0
manager.c,main,False,False,139,CWE-,CallExpression,strncpy,1171,-3,"['    int i, c;\n', '    char *acl             = NULL;\n', '    char *user            = NULL;\n', '    char *password        = NULL;\n', '    char *timeout         = NULL;\n', '    char *method          = NULL;\n', '    char *pid_path        = NULL;\n', '    char *conf_path       = NULL;\n', '    char *iface           = NULL;\n', '    char *manager_address = NULL;\n', '    char *plugin          = NULL;\n', '    char *plugin_opts     = NULL;\n', '    int server_num = 0;\n', '    jconf_t *conf = NULL;\n', '    static struct option long_options[] = {\n', '    while ((c = getopt_long(argc, argv, ""f:s:l:k:t:m:c:i:d:a:n:6huUvA"",\n                            long_options, NULL)) != -1)\n', '        switch (c) {\n', '            manager_address = optarg;\n', '    if (manager_address == NULL) {\n', '        manager_address = ""127.0.0.1:8839"";\n', '        LOGI(""using the default manager address: %s"", manager_address);\n', '    struct manager_ctx manager;\n', '    manager.manager_address = manager_address;\n', '    parse_addr(manager_address, &ip_addr);\n', '    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n', '        struct sockaddr_un svaddr;\n', '        svaddr.sun_family = AF_UNIX;\n', '        strncpy(svaddr.sun_path, manager_address, sizeof(svaddr.sun_path) - 1);\n']","int  Var1,Var2; 
char *Var3=NULL ; 
char *Var4=NULL ; 
char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
char *Var8=NULL ; 
char *Var9=NULL ; 
char *Var10=NULL ; 
char *Var11=NULL ; 
char *Var12=NULL ; 
char *Var13=NULL ; 
int  Var14=0; 
STRUCT1 *Var15=NULL ; 
static struct  STRUCT2  Var16[]={
while ((Var2=getopt_long(Var17,Var18,STRING,
Var16,NULL )) != -1)
switch (Var2){
Var11=Var19; 
if (Var11 == NULL ){
Var11=STRING; 
FUNC1(STRING,Var11); 
struct  STRUCT3  Var20; 
Var20.memberVar1=memberVar1; 
FUNC2(memberVar1,&Var21); 
if (Var21.memberVar1 == NULL ||Var21.memberVar2 == NULL ){
struct  STRUCT4  Var22; 
Var22.memberVar1=Var23; 
strncpy(Var22.memberVar2,memberVar1,sizeof (Var22.memberVar2)-1); 
",330,0
