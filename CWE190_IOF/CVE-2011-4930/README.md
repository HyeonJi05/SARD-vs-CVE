# 📁 CVE-2011-4930

## 🔍 취약점 개요

**🔗 [커밋 링크](https://github.com/htcondor/htcondor/commit/5e5571d1a431eb3c61977b6dd6ec90186ef79867)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2011-4930)**

> HTCondor 7.2.0 \~ 7.6.4 및 일부 7.7.x 버전의 `credd.cpp` 파일에서 `sprintf`에 사용자 입력이 포맷 문자열로 직접 사용되어 발생하는 \*\*형식 문자열 취약점(CWE-134)\*\*입니다. 공격자는 서비스 거부를 유발하거나 포맷 문자열 조작을 통해 메모리 접근이 가능합니다.

**취약점 종류**: \[[CWE-134](https://cwe.mitre.org/data/definitions/134.html)] Use of Externally-Controlled Format String

* **Source**: 사용자 입력을 포함한 전체 credential 문자열
* **취약 조건**: `:` 구분자를 포함한 credential 입력이 들어올 경우, `:` 이후 문자열이 포맷 문자열로 직접 사용됨
* **Sink**: `sprintf()` – 포맷 문자열이 해석되는 함수

## 📄 CVE-2011-4930 분석 대상 선정 요약

| 파일명                          | 포맷 함수 유형      | 취약점 수정 방식            | 구조 유사성 | 비고                         |
|--------------------------------|----------------------|-----------------------------|--------------|------------------------------|
| credd.cpp                      | sprintf              | `char*` → `"%s", char*`     | ✅ 동일      | C 스타일 포맷 문자열 직접 사용 |
| gahp-client.cpp                | dprintf, EXCEPT      | `buf.c_str()` → `"%s", ...` | ✅ 동일      | C++ 객체 문자열 사용 방식 유사 |
| condor_auth_ssl.cpp            | macro (dprintf)      | `x` → `"%s", x`             | ✅ 동일      | 매크로 내부에서 포맷 보완     |
| rm.cpp                         | sprintf              | `func()` → `"%s", func()`   | ✅ 동일      | 함수 반환값 포맷 적용         |
| NTreceivers.cpp               | msg.sprintf_cat      | `next` → `"%s", next`       | ✅ 동일      | 사용자 입력 문자열 적용       |

✅ **결론:** 구조 및 패치 방식이 모두 유사하므로, 대표성 있는 1~2개 파일만 분석 대상으로 삼아도 충분합니다.

---

## 📊 탐지 결과 요약

| 총 슬라이스 수 | 취약으로 탐지 | 정상으로 탐지 |
|----------------|----------------|----------------|
| 29개           | 0개            | 29개           |

\* CVE 설명에 나온 기준 함수(`Caller`: `rm_cred_handler`, `criterion`: `sprintf`)는 슬라이스 목록에 존재하지 않음.

#### 📌 실제 슬라이스 Caller / Criterion 목록 (일부):

```
Caller: SaveCredentialList  criterion: fprintf  
Caller: SaveCredentialList  criterion: fclose  
Caller: LoadCredentialList  criterion: fgets  
Caller: LoadCredentialList  criterion: fclose  
Caller: RefreshProxyThruMyProxy  criterion: strerror  
Caller: RefreshProxyThruMyProxy  criterion: write  
Caller: RefreshProxyThruMyProxy  criterion: strlen  
Caller: RefreshProxyThruMyProxy  criterion: free  
Caller: RefreshProxyThruMyProxy  criterion: chmod  
Caller: isSuperUser  criterion: strcmp  
Caller: Init  criterion: free  
Caller: Init  criterion: close  
Caller: StoreData  criterion: write  
Caller: StoreData  criterion: close  
Caller: LoadData  criterion: fprintf  
Caller: LoadData  criterion: read  
Caller: LoadData  criterion: close  
Caller: LoadData  criterion: malloc  
Caller: LoadData  criterion: memcpy  
Caller: init_user_id_from_FQN  criterion: strdup  
Caller: init_user_id_from_FQN  criterion: strchr  
Caller: init_user_id_from_FQN  criterion: free  
```

---

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

## 📌 CWE-134 탐지와 AI 모델 인식 한계 요약

### 1. AI 모델의 학습 방식

* 대부분의 CWE-134 학습은 **`sprintf`, `printf`, `fprintf`** 등 포맷 문자열이 직접 사용되는 호출 패턴을 중심으로 함
* `"sprintf(user_input)"` 형태가 대표적인 취약 패턴으로 인식됨

---

### 2. 실제 CVE의 코드 구조

* 포맷 문자열이 사용자 입력으로 직접 조합된 구조로 매우 전형적인 CWE-134 패턴
* 그러나 해당 슬라이스에서는 `sprintf`가 분석 대상(Caller, criterion)에 존재하지 않음

---

### ⚠️ 탐지 결과 문제점

1. **Sink 식별 실패**:

   * `sprintf` 호출이 있음에도 불구하고 이것이 포함된 슬라이스를 추출하지 않음
   * 포맷 문자열 취약점을 일으키는 대표 함수임에도 탐지되지 않음
   * 📄 근거: `test_output.csv`

2. **입력 → Sink 흐름 미인식**:

   * 실제 취약한 `sprintf` 호출 구문이 슬라이스에 포함되지 않았음
   * 따라서 외부 입력이 Sink로 전달되는 흐름 자체가 분석 대상에서 누락됨
   * 이는 슬라이서가 `sprintf`를 기준 함수(criterion)로 인식하지 못했거나,
     해당 코드 블록이 슬라이스 추출 조건을 만족하지 못했기 때문
   * 📄 근거: `test_output.csv`

3. **CPG 생성 단계에서 함수 호출 누락**

   * `before_credd.cpp`를 기반으로 생성된 CPG 내 `nodes.csv`에서 `sprintf` 호출 노드 자체가 존재하지 않음
   * Joern 기반 CPG 생성 시, 특정 조건에서 함수 호출 노드가 누락되는 문제로 인해 이후 단계에서 슬라이싱 자체가 불가능
   * 이로 인해 `get_criterion()` 단계에서 해당 함수가 탐지되지 않으며, 결국 슬라이스 미생성 → 탐지 실패로 이어짐
   * 📄 근거: `credd_nodes.csv`

---

## 🧠 추가 분석 정보

### 🧪 내부 코드 분석을 통한 추가 실패 원인

다음은 `get_criterion()` 함수의 내부 동작과 이를 기반으로 분석한 실패 원인입니다.(`⚠️ 탐지 결과 문제점`의 3과 관련)

#### 1. Criterion 추출 조건 정리

```python
if node_type in ["CallExpression"]:
    function_name = nodes[node_idx + 1]['code']
    if function_name not in l_funcs:
        continue  # criterion으로 포함되지 않음
```

* `l_funcs`: 사전에 정의된 취약 함수 목록
* 노드 타입이 `CallExpression`이고, 해당 함수명이 `l_funcs`에 없으면 criterion으로 등록되지 않음

#### 2. `credd.cpp`의 `sprintf()` 사례

* `sprintf`는 `l_funcs`에 존재 → 기준 함수로 사용 가능한 조건을 충족
* 그러나 슬라이스 결과를 보면 **어떤 슬라이스에서도 criterion에 포함되지 않음**
* 이유: **nodes.csv에 `sprintf` 노드가 아예 존재하지 않음**

#### 3. 핵심 원인: CPG 생성 단계에서 `sprintf()` 호출 노드 누락

| 단계           | 내용                          | 결과                            |
| ------------ | --------------------------- | ----------------------------- |
| 원본 C 코드      | `sprintf(...)`가 존재          | 확인됨                           |
| Joern CPG 파싱 | `nodes.csv`, `edges.csv` 생성 | **`sprintf` 호출이 노드로 변환되지 않음** |
| criterion 추출 | `get_criterion()` 함수 실행     | 기준 함수 미포함 → 슬라이싱 실패           |

---

### ✅ 요약

* 탐지 실패는 단순히 모델 학습이나 기준 함수 누락 문제가 아니라, **Joern 기반 CPG 생성 시점에서의 노드 누락 현상**이 주요 원인 중 하나임
* `sprintf` 함수 호출이 AST → CPG 변환 과정에서 누락될 경우, 해당 호출은 슬라이싱 대상이 될 수 없음
* 따라서 **Joern 파이프라인 상에서 함수 호출 노드의 누락 여부를 자동 검증하는 진단 로직 도입이 필요함**

---

## ✅ 개선 방향 제안

1. **Sink 정의 정확도 향상**:

   * `sprintf`와 같은 고전적인 포맷 함수 호출이 탐지에서 누락되지 않도록 기준 강화 필요

2. **데이터 흐름 추적 정밀도 개선**:

   * `sprintf` 등 포맷 함수에 전달되는 인자가 외부 입력에서 유입된 경우,
     그 유입 경로를 슬라이서와 모델이 정확히 추적할 수 있도록 개선해야 함
   * 특히 포맷 문자열 인자가 사용자 제어값일 때, 이를 명확히 구분해 CWE-134 흐름으로 연결되도록 해야 함

3. **CPG 생성 안정성 검증 강화**

   * AST → CPG 변환 과정에서 핵심 함수 호출 노드가 누락되지 않았는지 자동 검증하는 진단 로직 필요
   * 기준 함수(`l_funcs`)에 등록된 함수가 실제 노드에 존재하는지 사전 점검하여 슬라이스 누락 가능성을 줄여야 함

---

## 📁 취약점 세부 사항

| 파일명                | 설명           |
| ------------------ | ------------ |
| `before_credd.cpp` | 취약 코드 포함 파일  |
| `after_credd.cpp`  | 패치된 코드 포함 파일 |

### ❗️취약 코드

**취약 위치**: `before_credd.cpp:266`

```c
sprintf(name, (char*)(pColon + sizeof(char)));
```

* 사용자 입력 문자열에서 `:` 이후 부분을 `sprint`의 두 번째 인자인 포맷 문자열로 그대로 전달
* 사용자 입력에에 `%s`, `%x` 등이 포함될 경우 메모리 노출 또는 비정상 동작 유발 가능

### ✅ 개선 코드

**패치 위치**: `after_credd.cpp:266`

```diff
- sprintf(name, (char*)(pColon + sizeof(char)));
+ sprintf(name, "%s", (char*)(pColon + sizeof(char)));
```

**개선 방법**:

* 두 번째 인자인 포맷 문자열을 고정된 `"%s"`로 설정하여 외부 입력이 포맷으로 해석되지 않도록 처리
* 외부 입력(`sprintf`의 세 번째 인자)은 포맷 문자열(`sprintf`의 두 번째 인자) 인자로만 사용하여 CWE-134 공격 가능성 제거