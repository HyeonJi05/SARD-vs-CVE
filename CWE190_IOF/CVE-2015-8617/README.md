# 📁 CVE-2015-8617

## 🔍 취약점 개요

**🔗 [커밋 링크](https://github.com/php/php-src/commit/b101a6bbd4f2181c360bd38e7683df4a03cba83e)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2015-8617)**

> PHP 7.0.1 이전 버전의 `Zend/zend_execute_API.c`의 `zend_throw_or_error` 함수 내부에서 외부 입력을 문자열 메시지로 포맷팅한 후, `zend_throw_error()`를 통해 포맷 문자열 해석이 이루어지는 방식에서 발생하는 \*\*형식 문자열 취약점(CWE-134)\*\*입니다. 공격자가 포맷 문자열을 조작하여 임의 코드 실행이나 비정상 동작을 유발할 수 있습니다.

**취약점 종류**: \[[CWE-134](https://cwe.mitre.org/data/definitions/134.html)] Use of Externally-Controlled Format String

* **Source**: 외부에서 제어 가능한 상수 이름(예: 클래스명 문자열)
* **취약 조건**: 상수가 존재하지 않을 때 예외 메시지를 출력하며 포맷 문자열에 유입됨
* **Sink**: `zend_throw_error()` – 포맷 문자열이 실제로 해석되는 함수

---

## 탐지 결과 요약

| 총 슬라이스 수 | 취약으로 탐지 | 정상으로 탐지 |
| -------- | ------- | ------- |
| 16개      | 0개      | 16개     |

\* CVE 설명에 나온 기준 함수(`Caller`: `zend_throw_or_error`, `criterion`: `zend_throw_error`)는 슬라이스 목록에 존재하지 않음.

#### 📌 실제 슬라이스 Caller / Criterion 목록 (일부):

```
Caller: zend_handle_sigsegv  criterion: signal  
Caller: zend_handle_sigsegv  criterion: fprintf  
Caller: init_executor  criterion: signal  
Caller: init_executor  criterion: memset  
Caller: shutdown_executor  criterion: signal  
Caller: zval_update_constant_ex  criterion: memmove  
Caller: zend_call_function  criterion: memset  
Caller: zend_lookup_class_ex  criterion: strspn  
Caller: zend_eval_stringl  criterion: memcpy  
Caller: zend_eval_string  criterion: strlen  
Caller: zend_eval_string_ex  criterion: strlen  
Caller: zend_verify_abstract_class  criterion: memset  
Caller: zend_set_local_var  criterion: memcmp  
Caller: zend_set_local_var_str  criterion: memcmp  
```

---

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

## 📌 CWE-134 탐지와 AI 모델 인식 한계 요약

### 1. AI 모델의 학습 방식

* 대부분의 CWE-134 학습은 **`sprintf` / `printf` / `fprintf`** 등 **직접적인 포맷 함수 호출 패턴**을 기준으로 이루어짐
* 특히 `"sprintf(user_input)"`과 같은 **포맷 문자열 자리에 외부 입력이 직접 들어가는 구조**가 주요 탐지 포인트

---

### 2. 실제 CVE의 코드 구조

* 많은 CVE는 직접적인 `sprintf` 호출 대신, `zend_throw_error()`와 같은 사용자 정의 함수에 포맷 문자열이 전달됨
* 포맷 문자열은 `zend_vspprintf()`로 조합되지만, **포맷 문자열 해석은 `zend_throw_error()`에서 일어남**
* 결과적으로 외부 입력이 포맷 문자열로써 최종 해석되는 구조이나, AI는 이를 인식하기 어려움

---

### 3. 탐지의 어려움

* 일반 AI 모델은 **함수 호출 체인(Call Chain)을 추적하지 못함**
* `zend_throw_error()`가 포맷 문자열 함수(`printf` 등)처럼 Sink로 학습되지 않았을 경우 탐지 실패

---

### ✅ 결론

> 실제 CWE-134 발생 위치는 `zend_throw_error()`이나, AI 모델이 이를 포맷 문자열 Sink로 인식하지 못하면 탐지가 어려움

**→ 해결을 위해서는 `zend_throw_error()`를 Sink로 지정하거나, 호출 체인을 flatten하여 학습이 필요함.**

---

### ⚠️ 탐지 결과 문제점

1. **슬라이싱 누락**:

   * 실제 취약한 구문인 `zend_throw_or_error(NULL, format, ...)` 호출이 슬라이싱 대상에서 제외됨
   * `criterion`에 `zend_throw_or_error`나 최종 Sink인 `zend_throw_error`가 없음
   * 📄 근거: `test_output.csv`

2. **Sink 식별 실패**:

   * 포맷 문자열 해석 함수인 `zend_throw_error()`가 Sink로 태깅되지 않음
   * `"Sink": false`로 처리되어 CWE-134 흐름 인식 실패
   * 📄 근거: `test_output.csv`

3. **기준 함수 누락 문제**:

   * 실제 취약점이 발생하는 함수는 `zend_throw_error()`이며, 이 함수가 포맷 문자열을 해석함
   * 슬라이서가 이를 기준 함수(Sink)로 인식하지 않아 CWE 흐름 탐지 실패
   * 📄 근거: `test_output.csv`

---

## 🧠 추가 분석 정보

### `zval_update_constant_ex`는 왜 슬라이스에 포함되었는가?

`zval_update_constant_ex`는 실제로 취약 함수인 `zend_throw_or_error()`를 내부에서 호출합니다. 그러나 슬라이서가 슬라이스를 생성한 기준 함수(`criterion`)는 `zend_throw_or_error()`도 아니고, 최종 Sink인 `zend_throw_error()`도 아닙니다.
대신 `memmove()`가 슬라이서 기준 함수로 지정되어 있어 **CWE-134와 무관한 이유로 슬라이스가 생성된 것**입니다.
즉, 실제 취약 흐름과 관계없는 슬라이스만 생성되었기 때문에 CWE-134 탐지가 실패한 것입니다.

---

## ✅ 개선 방향 제안

1. **슬라이서 기준 함수 정의 개선**:

   * `zend_throw_error()`를 CWE-134용 Sink로 지정해야 함
   * 포맷 문자열이 사용자 입력으로 조합되어 해당 함수에 전달되는 구조를 인식할 수 있어야 함

2. **Sink 정의 확장**:

   * 포맷 문자열을 해석하는 사용자 정의 함수도 Sink 목록에 포함
   * 기존의 `printf`, `sprintf`뿐 아니라 `zend_throw_error` 같은 함수도 학습에 포함해야 함

3. **함수 호출 관계 Flatten**:

   * 포맷 문자열이 함수 호출 체인을 따라 전달되는 구조를 flatten하여 분석할 수 있도록 모델 개선 필요

---

## 📁 취약점 세부 사항

| 파일명                         | 설명          |
| --------------------------- | ----------- |
| `before_zend_execute_API.c` | 취약 코드 포함 파일 |
| `after_zend_execute_API.c`  | 패치된 코드 포함 파일 |

### ❗️취약 코드

```c
zend_throw_error(exception_ce, message);
```

* `message`는 외부 입력을 포함한 포맷 문자열로 `zend_vspprintf()`에서 생성됨
* 이 문자열이 포맷 문자열로 그대로 해석되어 CWE-134 취약점 발생 가능

### ✅ 개선 코드

```diff
- zend_throw_error(exception_ce, message);
+ zend_throw_error(exception_ce, "%s", message);
```

**개선 방법**:

* 외부 입력이 포함된 문자열을 포맷 문자열로 직접 사용하지 않고, 고정된 `"%s"`를 사용해 안전하게 출력함
* 이로써 포맷 문자열 취약점(CWE-134) 발생 가능성 제거
