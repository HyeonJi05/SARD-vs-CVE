# 📁 CVE-2015-8617

## 🔍 취약점 개요

**🔗 [커밋 링크](https://github.com/php/php-src/commit/b101a6bbd4f2181c360bd38e7683df4a03cba83e)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2015-8617)**  

> PHP 7.0.1 이전 버전의 `Zend/zend_execute_API.c`의 `zend_throw_or_error` 함수에서 포맷 문자열 지정자를 포함한 입력을 `zend_vspprintf`로 전달하여 발생하는 **형식 문자열 취약점(CWE-134)**입니다. 이로 인해 공격자가 임의 코드 실행 또는 예외적 동작을 유발할 수 있습니다.

**취약점 종류**: [[CWE-134](https://cwe.mitre.org/data/definitions/134.html)] Use of Externally-Controlled Format String

* **Source**: 외부에서 제어 가능한 상수 이름(예: 클래스명 문자열)
* **취약 조건**: 상수가 존재하지 않을 때 예외 메시지를 출력하며 포맷 문자열에 유입됨
* **Sink**: `zend_vspprintf()` – 포맷 문자열이 처리되는 내부 함수

---

## 탐지 결과 요약

| 총 슬라이스 수 | 취약으로 탐지 | 정상으로 탐지 |
|----------------|---------------|----------------|
| 16개           | 0개           | 16개           |

\* CVE 설명에 나온 취약한 함수(`Caller`) 혹은 내부 취약 함수(`criterion`)를 기준으로 슬라이스를 필터링함

| FileName               | Caller                  | Source | Sink | idx | CWE-ID | category       | criterion       | line | label | predict |
|------------------------|-------------------------|--------|------|-----|--------|----------------|------------------|------|--------|---------|
| zend_execute_API_before.c | zval_update_constant_ex | False  | False| 6   | CWE-   | CallExpression | memmove          | 594  | -3     | 0       |

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

AI 모델은 CWE-78의 경우 strcat() 함수가 슬라이스에 존재해야 취약으로 판단하는데, 이 취약점의 경우 system() 함수만 포함되어 있어 정상으로 판단된 것으로 보임.

---

### ⚠️ 탐지 결과 문제점

1. **슬라이싱 누락**:
   - 실제 취약한 구문인 `zend_throw_or_error(NULL, "...%s...", Z_STRVAL_P(p))`이 슬라이싱 대상에서 제외됨
   - `criterion`에 `zend_throw_or_error`나 내부 호출 `zend_vspprintf`가 없음
   - 📄 근거: `slicer_result.json`, `vectors.json`

2. **Sink 식별 실패**:
   - 포맷 문자열 처리 함수인 `zend_vspprintf()`가 `Sink`로 태깅되지 않음
   - `"Sink": false`로 처리되어 CWE-134 흐름 인식 실패
   - 📄 근거: `slicer_result.json`, `test_output.csv`

3. **슬라이스 분절 문제**:
   - 호출 함수(`zval_update_constant_ex`) 내에서 중첩 조건 분기와 함께 `zend_throw_or_error()`가 호출되나, 해당 블록이 슬라이스에서 제외됨
   - 📄 근거: `vectors.json`

---

## 🧠 추가 분석 정보

### 🔎 Slicer 추출 코드 (실제 취약 코드)
```c
zend_throw_error(NULL, "Undefined class constant '%s'", Z_STRVAL_P(p));
```

📄 추출 코드는 아니고 실제 취약 코드인데 해당 라인은 슬라이스에서 누락됨  
→ 결과적으로 `"criterion": "memmove"`가 포함된 슬라이스(`zval_update_constant_ex`)만 생성됨

---

## 🔍 보충 설명: `zval_update_constant_ex`는 왜 슬라이스에 포함되었는가?

- `zval_update_constant_ex`는 실제로 취약 함수인 `zend_throw_or_error()`를 **내부에서 호출**합니다.
- 하지만 CWE 설명이나 공식 CVE 정보에는 **직접적으로 언급되지 않은 상위 함수**입니다.
- 슬라이서가 `zend_throw_or_error`를 기준으로 슬라이스를 생성하지 못했기 때문에, 상위 컨텍스트 함수인 `zval_update_constant_ex`의 일부 코드만 포함됨
- 실제 슬라이스 기준 함수는 `memmove()` 등 CWE-134와 무관한 함수로 지정되어 탐지 실패로 이어졌습니다.

---

## ✅ 개선 방향 제안

1. **슬라이서 정밀도 개선**:
   - `zend_throw_or_error()` 및 `zend_vspprintf()`를 기준으로 슬라이싱 기준을 추가할 필요
   - 중첩 조건문 안에서도 호출되는 포맷 함수는 반드시 포함되어야 함

2. **Sink 정의 확장**:
   - 포맷 문자열 관련 함수(`vsprintf`, `zend_vspprintf`)도 Sink로 정의해야 CWE-134 대응 가능

3. **슬라이스 범위 확대**:
   - 입력-출력 흐름이 명확하게 연결되도록 슬라이스 범위를 함수 내 블록 전체까지 고려

---

## 📁 취약점 세부 사항

| 파일명 | 설명 |
|--------|------|
| `zend_execute_API_before.c` | 취약 코드 포함 파일 |

### ❗️취약 코드

```c
zend_throw_error(NULL, "Undefined class constant '%s'", Z_STRVAL_P(p));
```

- 사용자가 정의하지 않은 상수명을 입력할 경우 이 함수가 호출됨
- `%s` 포맷 문자열에 외부 입력이 포함될 수 있어 포맷 문자열 취약점 발생 가능

### ✅ 개선 코드

```diff
- zend_throw_error(NULL, "Undefined class constant '%s'", Z_STRVAL_P(p));
+ zend_throw_error(NULL, "%s", "Undefined class constant");
```

**개선 방법**:
- `%s` 포맷 문자열에 외부 입력(`Z_STRVAL_P(p)`)을 그대로 전달하지 않도록 수정
- 사용자 입력을 포맷 문자열 인자로 사용하는 행위를 지양하거나, 별도로 이스케이프 처리 수행
